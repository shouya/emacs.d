#+TITLE: My Emacs Preferences
#+latex_compiler: xelatex
#+latex_header: \usemintedstyle{emacs}

* Boot up
** Enable packages are loadable

=lisp/= stores modules I copied from [[https://github.com/purcell/emacs.d][purcell/emacs.d]].

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

=site-lisp/= stores downloaded modules that are not on MELPA.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
#+END_SRC

** Install =use-package= with straight.el
Ensure =use-package= is installed.

#+BEGIN_SRC emacs-lisp
(defvar use-package-compute-statistics)
(defvar straight-use-package-by-default)

(straight-use-package 'use-package)
(setq use-package-compute-statistics t)
(setq straight-use-package-by-default t)
#+END_SRC

** Start server automatically

#+BEGIN_SRC emacs-lisp
(use-package server
  :straight (:type built-in)
  :config
  (defun shou/server-start ()
    (when (not (server-running-p))
      (server-start)))
  (add-hook 'after-init-hook 'shou/server-start))
#+END_SRC

** Start edit server (for browser extensions)

Browser extension: [[https://github.com/GhostText/GhostText][GhostText]]

#+BEGIN_SRC emacs-lisp
(use-package atomic-chrome
  :hook (emacs-startup . atomic-chrome-start-server)
  :if (display-graphic-p)
  :custom
  (atomic-chrome-url-major-mode-alist
   '(("wiki\\.lain\\.li" . mediawiki-mode)
     ("github\\.com" . gfm-mode))))
#+END_SRC

** Make window resizable by window manager

#+BEGIN_SRC emacs-lisp
(setq-default frame-resize-pixelwise t)
#+END_SRC

** Load some basic libraries

#+BEGIN_SRC emacs-lisp
(use-package dash :demand t)
(use-package f :demand t)
(use-package s :demand t)
#+END_SRC

** Helper functions

#+begin_src emacs-lisp
(defvar shou/cached-pass-entries '())

(defun shou/get-pass-entry (entry)
  (if-let ((value (assoc entry shou/cached-pass-entries)))
      (cdr value)
    (let ((file-name-handler-alist
           '(("\\.gpg\\(~\\|\\.~[0-9]+~\\)?\\'" . epa-file-handler))))
      (let ((pass-entry (auth-source-pass-get 'secret entry)))
        (push (cons entry pass-entry) shou/cached-pass-entries)
        pass-entry))))
#+end_src

** Set exec path

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path "/usr/local/bin")
(add-to-list 'exec-path (f-expand "~/.nix-profile/bin"))
(add-to-list 'exec-path (f-expand "~/.local/bin"))
(add-to-list 'exec-path (f-expand "~/.asdf/shims"))
(add-to-list 'exec-path (f-expand "~/.asdf/bin"))
(add-to-list 'exec-path (f-expand "~/.cargo/bin"))
(add-to-list 'exec-path (f-expand "~/.shell/bin"))
(setenv "PATH" (s-join ":" exec-path))
#+END_SRC

** Inhibit startup screen

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

** Restart emacs command

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC

** Boot-time configuration

Mute unimportant warnings at boot time.

#+begin_src emacs-lisp
;; Mute "ad-handle-definition: ‘url-cache-extract’ got redefined" warning
(setq ad-redefinition-action 'accept)
#+end_src

* General behavior
** Save customized settings in a separate file

By default the customization is saved into =init.el=. Avoid the mess by saving it
in a separate file =custom.el=.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
(load-file custom-file)
#+END_SRC

** macOS specific customization
*** Emacs release selection

Not all Emacs release works good under macOS. Here's the best one I found.

[[https://github.com/railwaycat/homebrew-emacsmacport]]

Features:

- Window resizable
- Good OS clipboard interaction
- Meta+Shift combo recognized in Emacs

*** Treat option key as meta

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default mac-option-modifier 'meta)
  (setq-default mac-command-modifier 'super))
#+END_SRC

*** Enable clipboard for terminal

#+BEGIN_SRC emacs-lisp
(use-package osx-clipboard
  :if (eq system-type 'darwin)
  :config (osx-clipboard-mode +1))
#+END_SRC

*** =Cmd+C/Cmd+C= for copying and pasting

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (global-set-key (kbd "s-c") 'kill-ring-save)
  (global-set-key (kbd "s-v") 'yank))
#+END_SRC

** =C-c e= to edit current preferences

#+BEGIN_SRC emacs-lisp
(define-key global-map
  (kbd "C-c e")
  (lambda ()
    (interactive)
    (find-file (expand-file-name "preferences.org" user-emacs-directory))))
#+END_SRC

** =C-x k= Kill current buffer

#+BEGIN_SRC emacs-lisp
(defun shou/kill-current-buffer nil
  (interactive)
  (kill-buffer (current-buffer)))
(bind-key "C-x k" 'shou/kill-current-buffer)
#+END_SRC

** =C-x C-b= to view ibuffer

#+BEGIN_SRC emacs-lisp
(bind-key "C-x C-b" 'ibuffer)
#+END_SRC

** Open scratch

#+BEGIN_SRC emacs-lisp
(defun scratch ()
  "open a scratch buffer"
  (interactive)
  (let* ((buffer-name (make-temp-name "scratch-"))
         (buffer (generate-new-buffer buffer-name))
         (scratch-dir (f-expand "~/tmp/scratch"))
         (target-file (format "%s/%s.org" scratch-dir buffer-name)))
    (make-directory scratch-dir 'parents)
    (set (make-local-variable 'major-mode) 'org-mode)
    (switch-to-buffer buffer)
    (write-file target-file)
    (org-mode)))
#+END_SRC

** Web browser

I use eww, firefox, and other programs to open web url in emacs.

#+begin_src emacs-lisp
(defun shou/open-zoom-url (url &optional _new_window)
  ;; avoid showing the *Async Shell Command* buffer
  (let ((async-shell-command-display-buffer nil))
    (async-shell-command (concat "zoom \"" url "\" >/dev/null 2>&1"))))

(if (< emacs-major-version 28)
    (setq browse-url-browser-function
          '(("zoom\.us" . shou/open-zoom-url)
            ("." . browse-url-default-browser)))
  (setq browse-url-handlers
        '(("zoom\.us" . shou/open-zoom-url)
          ("." . browse-url-default-browser))))
#+end_src

I also like to open the browser in a separate window instead of on the current
one.

#+BEGIN_SRC emacs-lisp
(defun shou/eww-browse-url-in-new-buffer (url &rest ignore)
  (interactive "sURL: ")
  (switch-to-buffer-other-window (get-buffer-create "*eww*"))
  (eww-browse-url url))
#+END_SRC

=eww-readable= makes the web page more readable by hiding unnecessary content, so
I switched to readable mode after a web page is rendered.

#+BEGIN_SRC emacs-lisp
;; (add-hook 'eww-after-render-hook 'eww-readable)
(setq eww-after-render-hook '())
#+END_SRC

** Startup profiler

#+BEGIN_SRC emacs-lisp
(use-package esup
  :commands (esup))
#+END_SRC

** Backup

#+BEGIN_SRC emacs-lisp
(let* ((base-dir (cond
                  ((f-directory? "~/.cache") "~/.cache")
                  (t "/tmp")))
       (backup-dir (f-join base-dir "emacs-backup")))
  (when (not (f-directory? backup-dir))(f-mkdir backup-dir))
  (setq backup-directory-alist `((".*" . ,backup-dir))
        auto-save-file-name-transforms `((".*" ,backup-dir t))))
#+END_SRC

** Recent file

#+begin_src emacs-lisp
(use-package recentf
  :ensure nil
  :bind ("C-x f" . shou/find-recent-file)
  :config
  (add-to-list 'recentf-exclude (rx "bookmarks" eol))
  ;; save 200 files instead of default 20 files in history
  (setq recentf-max-saved-items 200)
  (recentf-mode 1)
  (defun shou/find-recent-file ()
    (interactive)
    (find-file (completing-read "Choose recent file: " recentf-list))
    )
  (add-to-list 'marginalia-prompt-categories '("Choose recent file:" . file))
  )
#+end_src

** Bookmarks

I keep some frequently accessed files in emacs bookmark so I can quickly jump to them via C-x r b.

Key bindings:

- =C-x r m= (bookmark-set): add bookmark
- =C-x r b= (bookmark-jump): jump to a bookmark, select interactively
- =C-x r l= (list-bookmarks): list bookmarks for inspection (and deletion)

#+begin_src emacs-lisp
(use-package bookmark
  :custom
  ;; save bookmark whenever a bookmark is set
  (bookmark-save-flag 1)
  )
#+end_src

** Remove trailing whitespaces on save

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Sensible defaults

Copied from [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][hrs's config]] and [[https://github.com/technomancy/better-defaults/blob/master/better-defaults.el][technomancy's config]].

#+BEGIN_SRC emacs-lisp
;; Don't ask `yes/no?', ask `y/n?'.
(fset 'yes-or-no-p 'y-or-n-p)

;; If some text is selected, and you type some text, delete the selected text and start inserting your typed text
(delete-selection-mode t)

(setq
 ;; search apropos in docs
 apropos-do-all t
 ;; automatically append final new line
 require-final-newline t
 ;; visual bell
 visible-bell t)

;; I don't use bidir text at all. This hugely increase scroll speed.
(setq-default bidi-inhibit-bpa t)

;; enable minibuffer-in-minibuffer
(setq enable-recursive-minibuffers t)
#+END_SRC

** Save last position for each file

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook (lambda () (save-place-mode t)))
#+END_SRC

** Replace region directly

With this mode, when I select a region and start typing, the text will
replace the active region automatically. Similar to the behavior of
most GUI editors.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

** Watch for long pause and explain them

#+BEGIN_SRC emacs-lisp
(use-package explain-pause-mode
  :straight (:host github :repo "lastquestion/explain-pause-mode")
  :commands explain-pause-mode
  ;; only report if the pauses exceed 100ms
  :custom (explain-pause-blocking-too-long-ms 100)
)
#+END_SRC

** Set =text-mode= as the default mode

#+BEGIN_SRC emacs-lisp
(setq-default initial-major-mode 'text-mode)
#+END_SRC

** Unbind keys

Here I unbind keyboard shortcuts that I frequently mistype.

#+begin_src emacs-lisp
;; It was bound to kill-region or something.
;; I often accidentally deleted whole buffer with this key which is frastrating.
(unbind-key "s-x")

;; I use these two keys to jump to definitions
(add-hook 'emacs-startup-hook
           (lambda ()
             (bind-key "M-." 'xref-find-definitions)
             (bind-key "M-," 'xref-find-definitions-other-window)))
#+end_src

** Confirm before quitting

#+begin_src emacs-lisp
(setq confirm-kill-emacs #'yes-or-no-p)
#+end_src

** Better help

=helpful.el= shows useful extra information for =describe-{function,variable,key}=.

#+begin_src emacs-lisp
(use-package helpful
  :bind
  ("C-h k" . helpful-key)
  ("C-h f" . helpful-callable)
  ("C-h v" . helpful-variable)

  :config
  (add-hook 'helpful-mode-hook #'shou/set-tab-width-to-8)
  (defun shou/set-tab-width-to-8 nil (setq-local tab-width 8))
  )
#+end_src

** Pointer behaviour configuration

Disable middle and right mouse button. I never use them and often hit them mistakenly.

#+begin_src emacs-lisp
(global-unset-key [mouse-3])
(global-unset-key [mouse-2])
(global-unset-key (kbd "C-<mouse-1>"))
(global-unset-key (kbd "C-<mouse-2>"))
(global-unset-key (kbd "C-<mouse-3>"))
#+end_src

** Performance optimization for files with long lines

Refer to [[https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html][Comprehensive guide on handling long lines in Emacs]] for additional directions.

#+begin_src emacs-lisp
(if (version<= "27.1" emacs-version)
    (global-so-long-mode 1))
#+end_src

** Copy full path of current file

#+begin_src emacs-lisp
(defun shou/copy-full-path ()
  "Copy the full path of the current buffer to the kill ring."
  (interactive)
  (let ((path))
    (setq path
          (if (derived-mode-p 'dired-mode)
              (dired-get-filename)
            (buffer-file-name)))
    (if (not path)
        (message "full path not found: %s" (buffer-file-name))
      (message path)
      (kill-new path))))

(with-eval-after-load 'dired
  (bind-key "W" #'shou/copy-full-path dired-mode-map))
#+end_src


* UI
** Tweak main UI

Hide the title bar, menu bar, as well as the scroll bar.

#+BEGIN_SRC emacs-lisp
;; this one turns off slower so I deferred it to execute after boot
(when (boundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (boundp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (boundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC

Enable pixel-wise scrolling for mouse scroll-wheel. It looks nicer.

#+BEGIN_SRC emacs-lisp
;; disabling it for now as it sometimes causes emacs to hang
; (add-hook 'emacs-startup-hook 'pixel-scroll-mode)
#+END_SRC

Disable visual bell because Emacs for macOS renders it poorly.

#+BEGIN_SRC emacs-lisp
(setq-default ring-bell-function 'ignore)
#+END_SRC

Show file name in window title.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("%b - %m @ Emacs"))
#+END_SRC

Do not attempt to resize frame on font-size change, etc. (Copied from [[https://tony-zorman.com/posts/2022-10-22-emacs-potpourri.html][Emacs Potpourri]])

#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t)
#+end_src

Don't pop up UI dialog in any case:

#+begin_src emacs-lisp
(setq use-dialog-box nil)
#+end_src

** Install all-the-icon

In order for the icons to work it is very important that you install the Resource Fonts included in this package, they are available in the fonts directory. You can also install the latest fonts for this package in the (guessed?) based on the OS by calling the following function;

=M-x all-the-icons-install-fonts=

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

** Theme

I use =modus-operandi= theme because it's high contrast, colorful, and looks pristine.

#+BEGIN_SRC emacs-lisp
(setq shou/current-theme 'modus-operandi)
(setq custom--inhibit-theme-enable nil)

(load-theme shou/current-theme t)
#+END_SRC

** Set font families

I use "Input" as my default font face.

#+BEGIN_SRC emacs-lisp
;; (add-to-list 'default-frame-alist '(font . "Input-14"))

;; https://old.reddit.com/r/emacs/comments/1xe7vr/check_if_font_is_available_before_setting/
(defun font-exists-p (font)
  "check if font exists"
  (if (null (x-list-fonts font)) nil t))

(defvar shou/var-font-list)
(defvar shou/mono-font-list)
(defvar shou/var-font)
(defvar shou/mono-font)

(defun shou/set-mono-font (name)
  (when-let* ((exists (font-exists-p name))
              (font-spec (alist-get name shou/mono-font-list nil nil 'equal))
              (font-height (or (plist-get font-spec :height) 100))
              (font-rel-height (or (plist-get font-spec :rel-height) 1.0)))

    (setq shou/mono-font name)

    (set-frame-font name)
    (set-face-attribute 'default nil :family name :height font-height)
    (set-face-attribute 'fixed-pitch nil :family name :height font-rel-height)
    t))

(defun shou/set-var-font (name)
  (when-let* ((exists (font-exists-p name))
              (font-spec (alist-get name shou/var-font-list nil nil 'equal))
              (font-rel-height (or (plist-get font-spec :rel-height) 1.0)))

    (setq shou/var-font name)
		(set-face-attribute 'variable-pitch nil :family name :height font-rel-height)
    t))

(defun auto-set-fonts ()
  (when-let ((font (car (-filter 'font-exists-p (mapcar 'car shou/mono-font-list)))))
    (shou/set-mono-font font))
  (when-let ((font (car (-filter 'font-exists-p (mapcar 'car shou/var-font-list)))))
    (shou/set-var-font font)))

(setq shou/var-font-list
      '(("Spectral" :rel-height 1.07)
        ("Charter" :rel-height 1.07)))

(setq shou/mono-font-list
      '(("JetBrains Mono ExtraLight" :height 130)
        ("Noto Mono" :height 135)
        ("Fira Code Light" :height 130)
        ("Dejavu Sans Mono" :height 130)))

(auto-set-fonts)
#+END_SRC

** Font for non-latin scripts

Ensure non-latin scripts font are rendered in a consistent font.

#+begin_src emacs-lisp
(cl-loop for (script . font) in
         '((han . "Noto Sans CJK TC DemiLight")
           (kana . "Noto Sans CJK JP DemiLight")
           (hangul . "Noto Sans CJK KR DemiLight")
           (phonetic . "Noto Sans")
           (greek . "Noto Sans Light")
           )
         do
         (set-fontset-font t ;; font for 'default face
                           script
                           (font-spec :family font))
         )
#+end_src

** Fonts for special copoints


#+begin_src emacs-lisp
;; IPA symbols and diacritic marks
(set-fontset-font nil '(#x0250 . #x036F) (font-spec :family "DejaVu Sans Mono"))
#+end_src

** Ligature

#+begin_src emacs-lisp
(use-package ligature
  :straight (:host github :repo "mickeynp/ligature.el")
  :hook (prog-mode . ligature-mode)
  :when window-system
  :disabled
  :config
  ;; Fira code ligatures that I use
  (ligature-set-ligatures t '("www" ":="
                              ".." "..." "<=>" "=>" "->" "->>" "<-" "<->" "::"
                              "##" "###" "####" "#####" "######"
                              "<<" "<<<" ">>" ">>>" "//" "///"
                              "||" "&&"
                              ))
  (ligature-set-ligatures 'prog-mode
                          '("www" "==" "===" "=/=" "!==" "!="
                            ".." "..." "<=>" "=>" "->" "<-" "<->" "::"
                            "##" "###" "####" "#####" "######"
                            "<<" "<<<" ">>" ">>>" "//" "///"
                            "||" "&&" ))
  (ligature-set-ligatures 'coq-mode
                          '("==" "===" "=/=" "!==" "!="
                            ".." "..." "<=>" "=>" "->" "<-" "<->" "::"
                            "<<" "<<<" ">>" ">>>" "//" "///"
                            "||" "&&" "->>" "<<-" "<<->>" "-->" "!->" ))
  )
#+end_src

** Make italic face slanted

By default, emacs shows italic faces with an underline. Better simply show a slanted face.

#+begin_src emacs-lisp
(set-face-attribute 'italic nil :slant 'italic :underline nil)
#+end_src

** Modeline customization

Doom modeline

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :custom
  (doom-modeline-height 19)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-env-version nil)
  (doom-modeline-lsp t)
  (doom-modeline-modal-icon nil)
  (doom-modeline-buffer-state-icon t)
  (doom-modeline-project-detection 'projectile)
  (doom-modeline-persp-name nil)
  (doom-modeline-mu4e t)
  ;; do not use project relative path
  (doom-modeline-buffer-file-name-style 'buffer-name)

  :config
  (doom-modeline-mode 1))
#+END_SRC

** Highlight current line

#+BEGIN_SRC emacs-lisp
(dolist (hook '(prog-mode-hook
                text-mode-hook
                conf-mode-hook))
  (add-hook hook 'hl-line-mode))

;; avoid overriding foreground color
(custom-set-faces '(hl-line ((t (:background "white smoke")))))
#+END_SRC

** Highlight uncommitted changes

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :hook (emacs-startup . global-diff-hl-mode))
#+END_SRC

** Highlight bracket

#+BEGIN_SRC emacs-lisp
(defun shou/visualize-matching-parens ()
  (show-paren-mode +1)
  (setq show-paren-style 'mixed)
)
(use-package highlight-parentheses
  :commands
  (global-highlight-parentheses-mode
   highlight-parentheses-mode))


(add-hook 'emacs-startup-hook 'shou/visualize-matching-parens)
(add-hook 'emacs-startup-hook 'global-highlight-parentheses-mode)

#+END_SRC

** Blink cursor

#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 1)
#+END_SRC

** Window manipulation

| Key     | Function                              |
|---------+---------------------------------------|
| =C-x -= | split-window-below                    |
| =C-x ¦= | split-window-height                   |
| =C-x += | balance-windows                       |
| =C-x ^= | enlarge-window (height++)             |
| =C-x }= | enlarge-window-horizontally (width++) |
| =C-x }= | shrink-window-horizontally (width--)  |

Note: Enlarge another window with =C-x ^= to reduce the size of current window.

Note: Press =C-x z= and keep pressing =z= to repeat the last command.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-x -") 'split-window-below)
(define-key global-map (kbd "C-x |") 'split-window-right)

;; prefer splitting window vertically (|)
(setq split-width-threshold 140)
(setq split-height-threshold nil)
#+END_SRC

** Turn off auto window scroll to get faster movement

This trick is based on [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][motion - Emacs point(cursor) movement lag]].

#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC

** Window management with =ace-window=

#+BEGIN_SRC emacs-lisp
(defun shou/other-window-backwards ()
  (interactive)
  (other-window -1))

(use-package ace-window
  ;; :bind ("M-o" . ace-window)
  :bind*
  ("M-o" . other-window)
  ("M-O" . shou/other-window-backwards)
  :custom
  ;; show current action in minibuffer
  (aw-minibuffer-flag t)
  ;; don't grey out background
  (aw-background nil)
  ;; only jump between windows in the same frame
  (aw-scope 'frame)
  ;; custom actions
  (aw-dispatch-alist '((?o aw-flip-window)
                       (?B aw-switch-buffer-other-window "Switch buffer in other window")
                       (?x delete-window)
                       (?X aw-delete-window "Delete other window")
                       (?m aw-swap-window "Swap with window")
                       (?M aw-move-window "Move and override window at location")
                       (?C aw-copy-window "Copy and override window at location")
                       (?? aw-show-dispatch-help))))

;; Disable C-x o
(global-unset-key (kbd "C-x o"))
#+END_SRC

** Automatic resizing with golden-ratio.el

This allows the currently focusing window to expand to occupy a decent portion of the frame.

#+begin_src emacs-lisp
(use-package golden-ratio
  :straight (:host github :repo "shouya/golden-ratio.el")
  :hook (emacs-startup . golden-ratio-mode)
  :custom
  (golden-ratio-exclude-buffer-name
   '("*Ediff Control Panel*"))
  :config
  ;; Instead of each window occupies 0.618 of the screen, makes it
  ;; occupy half of the screen. This prevents unnecessary resizing
  ;; when two side-by-side windows are open.
  (setq golden-ratio--value 2.0)
  )
#+end_src

** Remember layout for undoing

Use =C-c <left>= and =C-c <right>= to undo layout.

#+begin_src emacs-lisp
(use-package winner
  :config
  ;; enable winner mode globally
  (winner-mode 1))
#+end_src

** Allow transposing window (swap between horizontal/vertical arrangement)

#+begin_src emacs-lisp
(use-package transpose-frame
  :init
  ;; window-redisplay-end-trigger was obsolete and removed from latest
  ;; emacs 29 snapshot.
  ;;
  ;; I fset these functions to ignore so tranpose-frame doesn't break.
  (when (not (fboundp 'window-redisplay-end-trigger))
    (fset 'window-redisplay-end-trigger 'ignore)
    (fset 'set-window-redisplay-end-trigger 'ignore))

  :commands (transpose-frame flip-frame)
  :bind ("C-x C-t" . transpose-frame)
  )
#+end_src

** Alert library

#+BEGIN_SRC emacs-lisp
(use-package alert
  :commands alert
  :custom
  (alert-default-style (cond
                        ((eq system-type 'darwin) 'osx-notifier)
                        ((display-graphic-p) 'libnotify)
                        (t 'mode-line))))
#+END_SRC

** Popup window manager

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :hook (emacs-startup . popwin-mode)
  :config
  (push '("*elixir-format-errors*" :noselect t) popwin:special-display-config)
  (push "*idris-repl*" popwin:special-display-config)
  (push '("*idris-holes*" :noselect t) popwin:special-display-config)
  (push '("*Help*" :stick t) popwin:special-display-config)
  (push "*Warnings*" popwin:special-display-config)
  (push "*rustfmt*" popwin:special-display-config)
  (push "*explain-pause-log*" popwin:special-display-config)
  (push "*explain-pause-profiles*" popwin:special-display-config)
  (push '("*Flycheck errors*" :position bottom :stick t) popwin:special-display-config)
  (push '(cargo-process-mode :position bottom :stick t :height 10) popwin:special-display-config)
)
#+END_SRC

** Startup dashboard

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  ;; this is no longer working because it depends on the legacy cl lib
  :disabled
  :config
  (dashboard-setup-startup-hook)
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  :custom
  (dashboard-items '((agenda . 7)
                     (recents . 5)
                     (projects . 5)))
  (dashboard-startup-banner 2)
  (dashboard-set-heading-icons t)
  (dashboard-set-file-icons t)
  (dashboard-set-navigator t)
  (dashboard-set-footer nil)
  )
#+END_SRC

** Page break lines =^L=

It render =^L= as a page break line, which is nicer to look at.

#+begin_src emacs-lisp
(use-package page-break-lines
  :hook (emacs-startup . global-page-break-lines-mode))
#+end_src

** Fun

#+begin_src emacs-lisp
(use-package zone
  :ensure nil
  :disabled t
  :config
  ;; zone out after 5 minutes
  (zone-when-idle 300)

  ;; do not scramble current buffer location
  (defun shou/save-execursion (f) (save-excursion (funcall f)))
  (advice-add 'zone :around #'shou/save-execursion)
  )
#+end_src

* File management
** Basic config

#+BEGIN_SRC emacs-lisp
(use-package dired
  :defer t
  :straight (:type built-in)
  :commands (dired dired-jump)
  :bind (:map dired-mode-map
              ("." . dired-hide-dotfiles-mode)
              )
  :custom
  ;; Copy file to split window
  (dired-dwim-target t)
  ;; Always copy recursively
  (dired-recursive-copies 'always)
  ;; Ask once before deleting
  (dired-recursive-deletes 'top)

  ;; used for deft
  (unbind-key "C-M-n" dired-mode-map)

  :config
  (use-package dired-x :straight (:type built-in)))
#+END_SRC

** Dired+

#+begin_src emacs-lisp
;; do not show compressed files with face for ignored files
;; this variable must be set before dired+ is loaded because it affects font-lock
(setq diredp-ignore-compressed-flag nil)

;; fail silently if dired+ is not installed
(require 'dired+ nil t)

;; face customization
(with-eval-after-load 'dired+
  (set-face-attribute 'diredp-dir-name nil :foreground "blue" :weight 'bold :background 'unspecified)
  (set-face-attribute 'diredp-ignored-file-name nil :foreground "darkgray")
  (set-face-attribute 'diredp-compressed-file-suffix nil :foreground 'unspecified :inherit 'diredp-compressed-file-name)
  (set-face-attribute 'diredp-file-suffix nil :foreground 'unspecified)
  (set-face-attribute 'diredp-file-name nil :foreground 'unspecified)
  (set-face-attribute 'diredp-write-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-read-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-exec-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-no-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-dir-priv nil :background 'unspecified :foreground "blue")
  (set-face-attribute 'diredp-symlink nil :background 'unspecified :foreground "magenta")
  (set-face-attribute 'diredp-date-time nil :background 'unspecified :foreground "RoyalBlue")
  (set-face-attribute 'diredp-flag-mark-line nil :background "gray94" :weight 'bold)
  (set-face-attribute 'diredp-flag-mark nil :background 'unspecified :foreground "orange")
  (set-face-attribute 'diredp-omit-file-name nil :strike-through 'unspecified)
  )

(defun shou/update-dired+ ()
  "Download the latest version of dired+."
  (interactive)
  ;; download
  (url-copy-file
   "http://www.emacswiki.org/emacs/download/dired+.el"
   "~/.emacs.d/site-lisp/dired+.el"
   t)
  ;; rebuild
  (byte-compile-file "~/.emacs.d/site-lisp/dired+.el")
  ;; reload
  (unload-feature 'dired+ t)
  (require 'dired+ nil t))
#+end_src

** Hide dot files by default

Hit =.= key to reveal the files.

#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :after dired
  :hook (dired-mode . dired-hide-dotfiles-mode)
)
#+END_SRC

** Hide details by default

The details can be revealed by hitting =(= key.

#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+END_SRC

** Make dired perform IO actions asynchronously

So it doesn't block the main UI when copying large files.

#+BEGIN_SRC emacs-lisp
(use-package async
  :config
  (dired-async-mode 1))
#+END_SRC

** Show human readable sizes

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lah")
#+END_SRC

** Copy buffer name with =C-x w=

#+begin_src emacs-lisp
(defun shou/kill-buffer-name ()
  (interactive)
  (kill-new (buffer-file-name))
  (message (format "Copied \"%s\"" (buffer-file-name)))
  )
(bind-key "C-x w" 'shou/kill-buffer-name)
#+end_src

** Find file with fd

#+begin_src emacs-lisp
(use-package find-file-in-project
  :config
  (when (executable-find "fd")
    (setq ffip-use-rust-fd t))
  )
#+end_src

** Disk usage

ncdu inside Emacs, works great over tramp.

#+begin_src emacs-lisp
(use-package disk-usage
  :commands (disk-usage disk-usage-here ncdu)
  :config
  (defalias 'ncdu #'disk-usage-here)
  )
#+end_src

** Perform xdg-open from dired

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :config
  (defun shou/xdg-open (file)
    "Open a file through xdg-open"
    (interactive "f")
    (let ((file (expand-file-name file))
          (process-connection-type nil))
      (message "Opening %s with xdg-open" file)
      (call-process-shell-command (format "xdg-open '%s' &" file))))

  (defun shou/dired-xdg-open ()
    (interactive)
    (dolist (file (dired-get-marked-files))
      (shou/xdg-open file)))

  (define-key dired-mode-map (kbd "C-c C-o") 'shou/dired-xdg-open)
  (define-key dired-mode-map (kbd "C-o") 'shou/dired-xdg-open)
)
#+end_src

* Editing
** Indentation

Use tab-width of 2 by default.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

Always indent with spaces.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Some modes set this variable automatically, so we need to override them.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda () (setq-default indent-tabs-mode nil)))
#+END_SRC

** Detect indentation using heuristics

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent :commands dtrt-indent-mode)
(defalias 'detect-indentation 'dtrt-indent-mode)
(defalias 'detect-tab-size 'dtrt-indent-mode)
#+END_SRC

** Cursor movement
*** Use subword mode everywhere

#+BEGIN_SRC emacs-lisp
; (use-package syntax-subword
;   :hook (emacs-startup . global-syntax-subword-mode))
#+END_SRC

** Undo tree with vundo

Undo-tree is good, but it sometimes slows down saving (uses too much memory), and I don't really need all its rich functionalities. Now I'm trying out vundo on emacs 28.

#+begin_src emacs-lisp
(use-package vundo
  ;; vundo requires emacs 28
  :when (version<= "28" emacs-version)
  :straight (vundo :type git :host github :repo "casouri/vundo")
  :bind ("C-x u" . vundo)
  :custom
  (vundo-compact-display t)
  )
#+end_src

When emacs version is lower, I still use undo-tree:

#+begin_src emacs-lisp
(use-package undo-tree
  :when (version< emacs-version "28")
  :hook (emacs-startup . global-undo-tree-mode)
  :custom
  ;; allow undo in active region only
  (undo-tree-enable-undo-in-region t)
  ;; do not create undo-tree history files =.file.~undo-tree~= under file directories
  (undo-tree-history-directory-alist '((".*" . "~/.cache/undo-tree")))
  )
#+end_src

** Minibuffer Completion

I now use vertico for minibuffer completion. It's considerably faster than ivy.

#+begin_src emacs-lisp
(use-package vertico
  :straight (:host github
             :repo "minad/vertico"
             :files (:defaults "extensions/*")
             :includes (vertico-repeat))
  :init
  (vertico-mode)

  :custom
  (vertico-cycle t)
  )
#+end_src

Press =M-r= to reveal the last completion session:

#+begin_src emacs-lisp
(use-package vertico-repeat
  :ensure nil

  :bind
  (:map minibuffer-local-map
        ("M-r" . vertico-repeat))

  :config
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

  ;; preserve history across restarts
  (add-to-list 'savehist-additional-variables 'vertico-repeat-history)
  )
#+end_src

Show rich info on the margin of vertico completion:

#+begin_src emacs-lisp
(use-package marginalia
  :init
  (marginalia-mode)

  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle))

  :config
  (setq marginalia-command-categories
        (append '((projectile-find-file . file)
                  (projectile-find-dir . file)
                  (projectile-switch-project . file))
                marginalia-command-categories))
  )
#+end_src

Save history across restarts.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Consulting operations

Make operations more interactive with =consult.el=.

#+begin_src emacs-lisp
(use-package consult
  :bind
  (("M-g g" . consult-goto-line)
   ;; any org heading
   ("C-c C-S-j" . consult-org-agenda)
   ("C-x b" . consult-buffer)
   ("M-s L" . consult-line-multi)
   ("M-s m" . consult-global-mark)

   :map org-mode-map
   ;; org heading of this file
   ("C-c C-j" . consult-org-heading)
   )

  :custom
  ;; only show preview when pressing M-.
  (consult-preview-key "M-.")

  :config
  ;; show preview automatically for some commands
  (consult-customize
   consult-goto-line
   :preview-key '(:debounce 0.1 any))

  (require 'recentf)
  )

(with-eval-after-load 'lsp-mode
  (use-package consult-lsp
    :bind (:map lsp-mode-map
                ("C-c C-j" . consult-lsp-symbols))))
#+end_src

** Use CtrlF to replace isearch

#+BEGIN_SRC emacs-lisp
(use-package ctrlf
  :bind ("C-s" . ctrlf-forward-default)
  :bind ("C-r" . ctrlf-backward-default)
  :bind ("C-M-s" . ctrlf-forward-alternate)
  :bind ("C-M-r" . ctrlf-backward-alternate)
  :bind ("M-s _" . ctrlf-forward-symbol)
  :bind ("M-s ." . ctrlf-forward-symbol-at-point)
)
#+END_SRC

** Combo key hints

I use =which-key= package to display a screen of hints when a key prefix is
entered.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :hook (emacs-startup . which-key-mode)
  :custom
  (which-key-idel-delay 1.5))
#+END_SRC

** Expand region (~C-=~, ~C--~, ~v =~, ~v -~)

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind (("C-=" . er/expand-region)
         ("C--" . er/contract-region))

  :custom
  (expand-region-subword-enabled t)

  :config
  ;; use syntax info in treesitter to mark nodes more properly
  ;; stolen from https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/20#issue-561155902
  (defun tree-sitter-mark-bigger-node ()
    (interactive)
    (when-let (root (tsc-root-node tree-sitter-tree))
      (let* ((mark (or (mark) (point)))
             (region-start (min (point) mark))
             (region-end (max (point) mark))
             (node (tsc-get-descendant-for-position-range root region-start region-end))
             (node-start (tsc-node-start-position node))
             (node-end (tsc-node-end-position node)))
        ;; Node fits the region exactly. Try its parent node instead.
        (when (and (= region-start node-start) (= region-end node-end))
          (when-let ((node (tsc-get-parent node)))
            (setq node-start (tsc-node-start-position node)
                  node-end (tsc-node-end-position node))))
        (set-mark node-end)
        (goto-char node-start))))

  (add-to-list 'er/try-expand-list
               #'tree-sitter-mark-bigger-node
               'append)
  )
;; :custom
;;
;; (expand-region-skip-whitespace t)
;; (expand-region-smart-cursor nil)

;; :config
;; (defun shou/er/mark-org-heading ()
;;   (when (org-at-heading-p)
;;     (end-of-line)
;;     (push-mark nil t t)
;;     (beginning-of-line)))

;; (require 'the-org-mode-expansions)
;; (defun shou/er/add-org-mode-expansions ()
;;   (set (make-local-variable 'er/try-expand-list)
;;        (append
;;         (remove #'er/mark-defun er/try-expand-list)
;;         '(org-mark-subtree
;;           er/mark-org-element
;;           er/mark-org-element-parent
;;           er/mark-org-code-block
;;           er/mark-sentence
;;           er/mark-org-parent
;;           er/mark-paragraph
;;           shou/er/mark-org-heading
;;           )))
;;   (set (make-local-variable 'er/save-mode-excursion)
;;        #'er/save-org-mode-excursion))

;; (er/enable-mode-expansions 'org-mode 'shou/er/add-org-mode-expansions)

;; ;; mainly for qualified names like "Struct::method".
;; (require 'cc-mode-expansions)
;; (er/enable-mode-expansions 'rust-mode 'er/add-cc-mode-expansions)
;; )
#+END_SRC

** Writing prose
*** Markdown format support

- Associate =.md= files with the mode
- Use =pandoc= to render the result (please ensure it

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands gfm-mode
  :mode (("\.md$" . gfm-mode)
         ("\.markdown$" . gfm-mode))
  :config
  (when (executable-find "pando")
    (setq-default markdown-command "pandoc --standalone --mathjax --from=markdown"))
  )

;; edit-indirect is required to edit code blocks in markdown
;; summon with <C-c '>
(use-package edit-indirect
  :commands edit-indirect-region)
#+END_SRC

*** Define the list of text mode hooks

#+BEGIN_SRC emacs-lisp
(setq-default text-mode-hooks
              '(text-mode-hook
                markdown-mode-hook
                gfm-mode-hook
                org-mode-hook))
#+END_SRC


*** Enable spell checking

**** flyspell

Remember to install =aspell= command line tool.

Correct word with =C-;= key.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :disabled
  :hook ((git-commit-mode org-mode text-mode) . flyspell-mode)
  :hook (prog-mode . flyspell-prog-mode)
  :commands flyspell-mode
  :custom
  ;; personal dictionary
  (ispell-personal-dictionary (expand-file-name "user-dict" user-emacs-directory))

  ;; sort correction by likelihood
  (flyspell-sort-corrections t)

  ;; save to personal dictionary without confirmation
  (ispell-silently-savep t)

  ;; use aspell rather than ispell
  (ispell-program-name (executable-find "aspell"))

  ;; automatically save to abbrev
  (flyspell-abbrev-p t)
  (flyspell-use-global-abbrev-table-p t)

  :config
  ;; run flyspell only on idle time to avoid performance issue
  (use-package flyspell-lazy
    :custom
    ;; check recent change after idle for 0.5 seconds
    (flyspell-lazy-idle-seconds 0.5)

    ;; check entire visible window after 10 seconds
    (flyspell-lazy-window-idle-seconds 10))

  ;; auto save words abbrev table
  (use-package flyspell-correct
    :bind (:map flyspell-mode-map
                ("C-;" . flyspell-correct-wrapper)))

  ;; it doesn't display well with visual-line-mode
  ;; (use-package flyspell-correct-popup :after flyspell-correct)

  ;; enable flyspell-lazy
  (flyspell-lazy-mode 1)
  )
#+END_SRC

**** Jinx

Run =apt install libenchant-2-dev libhunspell-dev hunspell hunspell-en-us= to install the dependencies.

#+begin_src emacs-lisp
(use-package jinx
  :hook (emacs-startup . global-jinx-mode)
  :bind (:map jinx-mode-map
              ("C-;" . jinx-correct))
  :custom
  (jinx-languages "en_US")
  (jinx-camel-modes '(prog-mode org-mode))

  :config
  (when (not (f-exists? "~/.config/enchant/enchant.ordering"))
    (f-mkdir-full-path "~/.config/enchant")
    (f-write "en_US:hunspell,aspell\n" 'utf-8
             "~/.config/enchant/enchant.ordering")
    (f-symlink (f-expand "~/.emacs.d/user-dict")
               "~/.config/enchant/en_US.dic"))

  :config
  (defun shou/jinx--add-to-abbrev (overlay choice)
    "Add word -> CHOICE to abbrev table. (word is under OVERLAY.)"
    (let ((word (buffer-substring-no-properties
                 (overlay-start overlay)
                 (overlay-end overlay))))
      (message "Abbrev: %s -> %s" word choice)
      (define-abbrev global-abbrev-table word choice)))

  (advice-add 'jinx--correct-replace :before #'shou/jinx--add-to-abbrev))
#+end_src

*** Visual line mode for text modes

#+begin_src emacs-lisp
(dolist (hook '(org-mode-hook text-mode-hook))
  (add-hook hook 'visual-line-mode))
#+end_src

*** Set fill column for visual line mode

By default =visual-line-mode= wraps around at the edge of the frames. Which makes it difficult to read if the frame is too wide.

=visual-fill-column-mode= enhances this by enforcing the wrapping earlier.

#+begin_src emacs-lisp
(use-package visual-fill-column
  :disabled t
  :commands visual-fill-column-mode
  :hook (emacs-startup . global-visual-fill-column-mode)

  :custom
  (visual-fill-column-width 100)
  (visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))

  :config
  (setq-default split-window-preferred-function
                'visual-fill-column-split-window-sensibly))
#+end_src

** Customize editing shortcuts
*** Transpose char (=C-t=)
#+BEGIN_SRC emacs-lisp
(defun shou/transpose-next-char ()
  (interactive)
  (save-excursion
    (forward-char)
    (transpose-chars 1)))

(bind-key "C-t" 'shou/transpose-next-char)
#+END_SRC

*** Join lines (=C-j=)

#+BEGIN_SRC emacs-lisp
(defun shou/join-line ()
  (interactive)
  (save-excursion
    (next-line)
    (delete-indentation)))
(bind-key* "C-j" 'shou/join-line)
#+END_SRC

*** Select whole line (=C-S-v=)

#+BEGIN_SRC emacs-lisp
(defun shou/mark-line ()
  (interactive)
  (when (not (region-active-p))
    (forward-line 0)
    (set-mark-command nil))
  (forward-line))
(bind-key "C-S-v" 'shou/mark-line)
#+END_SRC

*** Symbol case conversion

#+begin_src emacs-lisp
(defun shou/transform-thing-at-point (thing fn)
  "Transform thing at point with a string -> string function"
  (save-excursion
    (let* ((str (thing-at-point thing t))
           (region (bounds-of-thing-at-point thing))
           (replacement (funcall fn str)))
      (delete-region (car region) (cdr region))
      (insert replacement))))

(defun shou/to-upper-camel-case ()
  (interactive)
  (shou/transform-thing-at-point 'symbol #'s-upper-camel-case))

(defun shou/to-lower-camel-case ()
  (interactive)
  (shou/transform-thing-at-point 'symbol #'s-lower-camel-case))

(defun shou/to-snake-case ()
  (interactive)
  (shou/transform-thing-at-point 'symbol #'s-snake-case))
#+end_src

** Dictionary with =C-c C-d=

#+BEGIN_SRC emacs-lisp
(use-package osx-dictionary
  :if (eq system-type 'darwin)
  :bind ("C-c C-d" . osx-dictionary-search-word-at-point))
#+END_SRC

** Multi cursor

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-x m" . mc/mark-all-dwim)
         ("C-M-SPC" . mc/mark-next-lines)
         ("C->" . mc/mark-next-like-this-symbol)
         ("C-<" . mc/unmark-next-like-this)
         ("C-M->" . mc/skip-to-next-like-this)
         ("C-M-<" . mc/skip-to-previous-like-this))
  :config (define-key mc/keymap (kbd "<return>") nil))
#+END_SRC

** Visual query replace

#+begin_src emacs-lisp
(use-package visual-regexp
  :bind (("M-%" . vr/query-replace)))
#+end_src

** Align expression

#+begin_src emacs-lisp
(use-package bind-key
  :config
  (bind-key "M-^" 'align-regexp))
#+end_src

** TRAMP

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :straight nil
  :custom
  (tramp-default-method "scp")
  ;; cache file names for 10 seconds
  (remote-file-name-inhibit-cache 10)

  ;; do not store remote command history over tramp
  (tramp-histfile-override t)

  :config
  ;; stolen from https://stackoverflow.com/questions/33275790/how-sudo-edit-local-file-with-emacs-on-ubuntu
  (defun sudo-edit (&optional arg)
    "Edit currently visited file as root.

With a prefix ARG prompt for a file to visit.
Will also prompt for a file to visit if current
buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
  )
#+END_SRC

*** Tramp for kubernetes containers

#+begin_src emacs-lisp
(use-package kubernetes-tramp
  :when (f-exists-p "~/.kube/config")
  :custom
  (tramp-remote-shell-executable "sh")
  :config
  (let* ((paths (cons "~/.kube/config" (f-glob "~/.kube/config.d/*"))))
    (setenv "KUBECONFIG"
            (s-join ":" (mapcar 'f-expand paths)))))
#+end_src

** Auto-correction

I bind M-/ to cape-dabbrev, because dabbrev-completion doesn't search
other buffers by default. See [[https://stackoverflow.com/questions/22724087/dabbrev-expand-and-dabbrev-completion-inconsistent][emacs - dabbrev-expand and dabbrev-completion inconsistent? - Stack Overflow]].

#+begin_src emacs-lisp
(setq save-abbrevs 'silently)

;; auto enable abbrev mode
(use-package dabbrev
  :bind (;; ("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand)))

#+end_src

** MediaWiki

#+begin_src emacs-lisp
(use-package mediawiki
  :commands mediawiki-mode
  :config
  (unbind-key "<tab>" mediawiki-mode-map)
  (unbind-key "S-<tab>" mediawiki-mode-map)
  (unbind-key "S-<iso-lefttab>" mediawiki-mode-map)
  (unbind-key "<backtab>" mediawiki-mode-map)
  (unbind-key "C-<backslash>" mediawiki-mode-map)

  (bind-key "<tab>" #'completion-at-point mediawiki-mode-map)
  (bind-key "C-c !" #'shou/insert-wiki-date-link mediawiki-mode-map)
  (bind-key "C-c ." #'shou/insert-wiki-date-link mediawiki-mode-map)
  (bind-key "M-<return>" 'mediawiki-terminate-paragraph mediawiki-mode-map)

  (defun shou/default-date-from-firefox ()
    (let* ((line (shell-command-to-string "wmctrl -l -x | grep Firefox"))
           ;; matching text like Sep 20, 2022
           (regexp "[A-Z][a-z]\\{2\\} [0-9]\\{1,2\\}, [0-9]\\{4\\}")
           (match (s-match regexp line)))
      (pcase match
        (`(,text) text)
        (_ nil))))

  (defun shou/insert-wiki-date-link (arg)
    (interactive "P")
    (let* ((format "<[%b %-d, %Y]>")
           (org-time-stamp-formats (cons format format))
           (org-read-date-prefer-future nil)
           (default-date (shou/default-date-from-firefox))
           (time (org-read-date arg 'totime nil nil nil default-date)))
      (org-insert-time-stamp time t 'inactive)))
  )
#+end_src

** CSV file

#+begin_src emacs-lisp
(use-package csv-mode
  :commands csv-mode
  :mode (("\\.csv\\'" . csv-mode))
  :config
  (add-hook 'csv-mode-hook 'csv-align-mode))
#+end_src

** Quail

Add extra shortcuts for symbols I frequently use to the TeX input method.

#+begin_src emacs-lisp
(eval-after-load 'quail
  (with-temp-buffer
    (activate-input-method "TeX")
    (let ((quail-current-package (assoc "TeX" quail-package-alist)))
      (quail-define-rules ((append . t))
                          ("|-" ?⊢) ;; \vdash
                          ("|=" ?⊨)
                          ("=>" ?⇒)
                          ("\\lam" ?λ)
                          (":=" ?≔)
                          ("|->" ?↦) ;; \mapsto
                          ("-->" ?⟶) ;; \longrightarrow
                          ("\\sqrt" ?√) ;; \sqrt sometimes disappears
                          ("\\Phi" ?Φ)
                          ("\\dot" ?·)
                          ))))
#+end_src

** Jump to char quickly with Avy
#+begin_src emacs-lisp
(use-package avy
  :bind
  ("M-j" . avy-goto-char-timer)
  ("M-J" . avy-pop-mark)

  :custom
  (avy-style 'at-full)

  :config
  ;; https://karthinks.com/software/avy-can-do-anything/#avy-plus-embark-any-action-anywhere
  (defun shou/def/avy-action-at-point (:key key :action f)
    "define custom avy action"
    (let ((avy-action-name
           (intern (concat "avy-action-" (symbol-name f)))))
      (progn
        (eval `(defun ,avy-action-name (pt)
                 (unwind-protect
                     (save-excursion (goto-char pt) (funcall ',f))
                   (select-window (cdr (ring-ref avy-ring 0))))
                 t))
        (eval `(setf (alist-get ,key avy-dispatch-alist) ',avy-action-name)))
    ))

  (shou/def/avy-action-at-point
   :key ?L
   :action 'shou/copy-idlink-to-clipboard)
  (shou/def/avy-action-at-point
   :key ?m
   :action 'embark-act)
  (shou/def/avy-action-at-point
   :key ?K
   :action 'kill-whole-line)
  )
#+end_src

** Embark

#+begin_src emacs-lisp
(use-package embark
  :bind ("M-m" . embark-act)
  :config
  (embark-define-keymap embark-identifier-map
    "Actions on symbol"
    ("," xref-find-definitions)
    ("." xref-find-definitions-other-window)
    ("R" lsp-rename)
    ("g" rg-dwim)
    )
  )
#+end_src

** Scroll other window with M-up/down

Stolen from https://stackoverflow.com/a/45363946/1232832.

#+begin_src emacs-lisp
(define-key global-map [(meta up)]
  #'(lambda() (interactive) (scroll-other-window -1)))
(define-key global-map [(meta down)]
  #'(lambda() (interactive) (scroll-other-window 1)))
#+end_src


* Programming
** Show column number

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'column-number-mode)
#+END_SRC

Also show a ruler at column 80.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :hook (prog-mode . fci-mode)
  ;; it conflicts with company-mode, see https://github.com/company-mode/company-mode/issues/180
  :disabled
  :custom
  (fci-rule-column 80)

  ;; customize the look of the ruler
  (fci-rule-width 1)
  (fci-rule-use-dashes t)
  (fci-dash-pattern 0.3)

  ;; fci is incompatible with show-trailing-whitespace
  (show-trailing-whitespace nil))

(use-package display-fill-column-indicator
  :hook (prog-mode . display-fill-column-indicator-mode)
  :custom
  (display-fill-column-indicator-column 80)
  )
#+END_SRC

** Show line number

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)

;; (add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

** String edit in separate buffer

#+begin_src emacs-lisp
(use-package string-edit-at-point
  :commands string-edit-at-point
  :bind (:map prog-mode-map
              ("C-c '" . string-edit-at-point)))
#+end_src

** Jump to definition (=M-.=)

I use =dumb-jump=, which works out of the box for many languages. I prioritize lsp-mode's find-definition function if it works, otherwise fallback to dumb-jump.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :commands (dumb-jump-xref-activate)

  :custom
  (dumb-jump-selector 'completing-read)
  (dumb-jump-force-searcher 'rg)
  ;; Defaults to --pcre2. ripgrep's pcre is an opt-in feature that's not enabled by default.
  (dumb-jump-rg-search-args "--auto-hybrid-regex")
  )

(defun shou/xref ()
  (let ((loc (and lsp-mode
                  (lsp-request "textDocument/definition"
                               (lsp--text-document-position-params)))))
    (if (seq-empty-p loc)
        (dumb-jump-xref-activate)
      (lsp--xref-backend))))


(defun insert-dumb-jump-to-xref ()
  (setq-local xref-backend-functions '(shou/xref t)))

(add-hook 'prog-mode-hook 'insert-dumb-jump-to-xref)
#+END_SRC

** Enable flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :commands flycheck-mode
  :hook (prog-mode . flycheck-mode)

  :preface
  ;; adapted from
  ;; https://github.com/flycheck/flycheck/issues/1762#issuecomment-750458442
  (defvar-local shou/flycheck-local-cache nil)

  (defun shou/flycheck-checker-get (fn checker property)
    (or (alist-get property (alist-get checker shou/flycheck-local-cache))
        (funcall fn checker property)))

  (advice-add 'flycheck-checker-get :around 'shou/flycheck-checker-get)

  :custom
  ;; do not recheck syntax on newline or on save, which can result in
  ;; perceivable lagging.
  (flycheck-check-syntax-automatically '(mode-enable idle-change))
  ;; only check syntax after 4 seconds of idling
  (flycheck-idle-change-delay 4)

  :config
  ;; add frequent typo
  (define-key flycheck-mode-map (kbd "C-c 1") flycheck-command-map)

  ;; display pos-tip for flycheck errors
  (use-package flycheck-pos-tip
    ;; disabled because it uses a bit too much memory, resulting in
    ;; more gc pauses.
    :custom
    ;; do not timeout when I'm reading the text. (default: 5)
    (flycheck-pos-tip-timeout 30)

    :config
    (add-hook 'flycheck-mode-hook 'flycheck-pos-tip-mode)
    ))
#+END_SRC

** Highlight all occurrences word at point

#+BEGIN_SRC emacs-lisp
(use-package idle-highlight-mode
  :hook (fundamental-mode . idle-highlight-mode)
  :custom
  (idle-highlight-idle-time 0.5))
#+END_SRC

** Project management
*** Use =ripgrep= (rg)

I don't use deadgrep any more. rg + wgrep is better in terms of speed and the display is nicer.

Few shortcuts:

- press =C-c s s= to search current word
- on search window, =m= to bring up the menu (refine search, change dir, etc)
- on search window, =C-x C-q= to enable wgrep editing mode

#+BEGIN_SRC emacs-lisp
(use-package rg
  :bind (("C-c s s" . rg-dwim)
         ("C-c s p" . rg-project)
         ("C-c s r" . rg)
         ("C-c s t" . rg-literal)
         :map rg-mode-map
         ("C-x C-q" . wgrep-change-to-wgrep-mode))
  :custom
  ;; find when use
  (wgrep-auto-save-buffer t)

  :config
  (defun shou/switch-to-rg-buffer (&rest args)
    (switch-to-buffer-other-window "*rg*"))
  (advice-add 'rg-run :after #'shou/switch-to-rg-buffer)
  )
#+END_SRC

*** Use =projectile= to open files within project

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :custom
  (projectile-completion-system #'completing-read)
  (projectile-enable-caching nil)
  (projectile-indexing-method 'alien)
  (projectile-globally-ignored-file-suffixes '("beam"))
  (projectile-create-missing-test-files t)
  ;; speed up tramp (https://emacs.stackexchange.com/questions/17543/tramp-mode-is-much-slower-than-using-terminal-to-ssh)
  (projectile-mode-line "P")
  (projectile-switch-project-action 'shou/action-after-switch-project)
  (projectile-track-known-projects-automatically nil)

  :hook (after-init . projectile-mode)

  :bind-keymap
  ("M-`" . projectile-command-map)

  :config
  (setq projectile-globally-ignored-directories
        (append projectile-globally-ignored-directories
                '(".elixir_ls" "_build")))

  ;; Elixir: jump to *_test.exs instead of *_test.ex
  (defun shou/fix-exs-test-file-name (name)
    (cond
     ((string-suffix-p "_test.ex" name) (concat name "s"))
     (t name)))

  (advice-add #'projectile--test-name-for-impl-name
              :filter-return
              #'shou/fix-exs-test-file-name)

  (defun shou/action-after-switch-project ()
    "open magit or prompt for find file"
    (if (and (fboundp 'magit-git-repo-p)
             (magit-git-repo-p default-directory))
        (magit)
        (projectile-find-file)))
  )
#+END_SRC

*** Find project marker file

This helper function finds the marker files (Cargo.toml, mix.exs, etc) for the current project. If it's already opening a marker file, it will look from the parent directory. (For example, if current file is already =src/app/manager/mix.exs=, it may jump to =src/mix.exs=)

#+begin_src emacs-lisp
(defun shou/projectile-find-marker-file ()
  "Find the marker file (Cargo.toml, mix.exs, etc) for the current project."
  (interactive)
  (if-let* ((this-file (buffer-file-name))
            (marker-files (projectile-project-type-attribute
                           (projectile-project-type)
                           'marker-files))
            (get-target-marker-file
             (lambda (f)
               (when-let* ((dir (locate-dominating-file default-directory f))
                           (full-path (concat dir f))
                           (_ (not (f-same-p this-file full-path))))
                 full-path)))
            (marker-file (seq-find get-target-marker-file marker-files))
            (target-marker-file (funcall get-target-marker-file marker-file)))
      (find-file target-marker-file)
    (if-let* ((default-directory (f-dirname default-directory))
              (parent-marker-file (seq-find get-target-marker-file marker-files))
              (target-parent-marker-file (funcall get-target-marker-file parent-marker-file)))
        (find-file target-parent-marker-file)
      (message "No marker file found"))))

(with-eval-after-load 'projectile
  (bind-key "m" 'shou/projectile-find-marker-file projectile-command-map))
#+end_src

** Run command

#+begin_src emacs-lisp
(defun shou/run-command/submit-exercism ()
  (when-let* ((curr-root (projectile-project-root))
              (ex-root "~/projects/exercism")
              (_ (f-same? curr-root ex-root)))
    (list :command-name "Submit exercism"
          :command-line
          (lambda ()
            (->> (read-file-name "Submit file: " nil nil nil (buffer-file-name))
                 (format "exercism submit %s"))))))

(defun shou/run-command/yarn ()
  (when-let* ((file-name (buffer-file-name))
              (yarn-root (locate-dominating-file file-name "package.json")))
    (list :command-name "Yarn"
          :command-line
          (let (default-directory yarn-root)
            (lambda ()
              (->> (completing-read "yarn " '(" " "test"))
                   (format "yarn %s")))))))

(defvar shou/run-command/custom/hist '())
(defun shou/run-command/custom ()
  (list :command-name "Custom command"
        :command-line
        (lambda ()
          (when-let (cmd (completing-read "Enter your command: "
                                          (-map
                                           'substring-no-properties
                                           shou/run-command/custom/hist)
                                          nil nil nil
                                          'shou/run-command/custom/hist))
            cmd))))

(defun shou/run-command-recipe ()
  (list
   (shou/run-command/titan-release)
   (shou/run-command/submit-exercism)
   (shou/run-command/yarn)
   (shou/run-command/custom)
   ))

(use-package run-command
  :straight (:host github :repo "bard/emacs-run-command")
  :bind ("<f6>" . run-command)
  :commands run-command
  :custom (run-command-recipes (list #'shou/run-command-recipe))
  )
#+end_src

** Eshell

#+begin_src emacs-lisp
(use-package eshell
  :bind
  ("C-x e" . eshell)

  :custom
  (eshell-history-size 10240)
  (eshell-last-dir-ring-size 512)

  :preface
  (defun shou/def-eshell-alias (name def)
    (when (not (equal (eshell-lookup-alias name)
                      `(,name ,def)))
      (eshell/alias name def)))

  :config
  (setenv "KUBECONFIG"
          (s-join ":" (-map 'f-expand
                            (cons "~/.kube/config" (f-glob "~/.kube/config.d/*")))))

  (defun shou/eshell-insert-history-element ()
    (interactive)
    (insert (completing-read "Search history: " (ring-elements eshell-history-ring))))

  (defun shou/eshell-insert-arguments-from-previous-command ()
    "Bring up the arguments from the previous command. Similar to M-. in shell."
    (interactive)
    (let ((begin))
      (save-excursion
		    (eshell-previous-prompt 1)
        ;; to ensure the cursor lands on the beginning of word
        (eshell-forward-argument 1)
        (eshell-forward-argument 1)
        (eshell-backward-argument 1)
		    (setq begin (point))
        (end-of-line)
        (kill-ring-save begin (point)))
      (yank)))

  (defun shou/eshell-customization ()
    (bind-key "M-r" #'shou/eshell-insert-history-element eshell-mode-map)
    (bind-key "M-r" #'shou/eshell-insert-history-element eshell-hist-mode-map)
    (bind-key "M-." #'shou/eshell-insert-arguments-from-previous-command eshell-mode-map)

    ;; eshell-lookup-alias is defined buffer-locally
    (shou/def-eshell-alias "ll" "ls -al $*")
    (shou/def-eshell-alias "k" "kubectl $*")
    (shou/def-eshell-alias "z" "kubectl $*"))

  (add-hook 'eshell-mode-hook #'shou/eshell-customization)

  ;; eshell aliases
  (fset 'eshell/vi #'find-file)
  (fset 'eshell/ff #'find-file)

  (defun eshell/z (&optional regexp)
    "fasd-like cd"
    (if (not regexp)
        (eshell/cd "=")
      (eshell/cd (format "=%s" regexp))))

  ;; colorize command line tool outputs
  ;; stolen from https://old.reddit.com/r/emacs/comments/b6n3t8/what_would_it_take_to_get_terminal_colors_in/
  (add-hook 'eshell-mode-hook (lambda () (setenv "TERM" "xterm-256color")))
  )
#+end_src

** EAT

Emulate A Terminal (EAT) is a terminal emulator for Emacs written in native Elisp. Cheatsheet:

| Key       | Description              |
|-----------+--------------------------|
| =C-c C-e= | switch to emacs mode     |
| =C-c C-j= | switch to semi-char mode |

#+begin_src emacs-lisp
(use-package eat
  :straight '(eat :type git
                  :host codeberg
                  :repo "akib/emacs-eat"
                  :files ("*.el" ("term" "term/*.el") "*.texi"
	                        "*.ti" ("terminfo/e" "terminfo/e/*")
	                        ("terminfo/65" "terminfo/65/*")
	                        ("integration" "integration/*")
	                        (:exclude ".dir-locals.el" "*-tests.el")))
  :commands (eat eat-eshell-mode eat-project)
  :after projectile
  :bind
  ("C-x E" . eat)
  (:map projectile-command-map
   ("x E" . shou/eat-projectile))
  :hook
  (eshell-load . eat-eshell-mode)
  (eshell-load . eat-eshell-visual-command-mode)
  :custom
  ;; unlimited scrollback
  (eat-term-scrollback-size nil)
  :config
  (defun shou/eat-projectile (arg)
    (interactive "P")
    (require 'projectile)
    (let ((project (projectile-acquire-root)))
      (projectile-with-default-dir project
        (let ((eat-buffer-name
               (projectile-generate-process-name "eat" arg project)))
          (eat nil arg)))))

  ;; allow switching file via projectile (M-`)
  (add-to-list 'eat-semi-char-non-bound-keys [?\e ?`])
  (add-to-list 'eat-semi-char-non-bound-keys [C-n])
  (add-to-list 'eat-semi-char-non-bound-keys [C-p])
  (eat-update-semi-char-mode-map))
#+end_src

** Connect to external tmux session

Use commands like =emamux:send-buffer=.

#+begin_src emacs-lisp
(use-package emamux)
#+end_src

** Code folding

I use =yafolding= to fold structured code.

I didn't use =origami.el= because it handles languages like js/json terribly. =yafolding,= on the other hand, is based on indentation alone. This means as long as the document is well-indented, =yafolding= is able to fold correctly.

#+begin_src emacs-lisp
;; (use-package yafolding
;;   :hook (prog-mode . yafolding-mode))
#+end_src

#+begin_src emacs-lisp
(use-package ts-fold
  :straight (ts-fold :type git :host github :repo "emacs-tree-sitter/ts-fold")
  :after tree-sitter-langs
  :bind (:map prog-mode-map
              ("C-<return>" . ts-fold-toggle))
  )
#+end_src

** Auto complete parentheses

I use =smartparens= package for the purpose.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :hook (lisp-data-mode . smartparens-mode)
  :bind (("M-r" . sp-rewrap-sexp)
         :map smartparens-mode-map
              ;; ((a|) b) => ((a| b))
              ("M-L" . sp-forward-slurp-sexp)
              ;; ((a| b)) => ((a|) b)
              ("M-H" . sp-forward-barf-sexp)
              ;; (a (|b)) => ((a |b))
              ("M-S-h" . sp-backward-slurp-sexp)
              ;; ((a |b)) => (a (|b))
              ("M-S-l" . sp-backward-barf-sexp)
              ;; ((a|) b) => (a| b)
              ("M-j" . sp-splice-sexp)
              ;;
              ("M-<right>" . sp-next-sexp)
              ;;
              ("M-<left>" . sp-previous-sexp))
  :config
  (require 'smartparens-config)
  (sp-local-pair 'haskell-mode "'" nil :actions nil))
#+END_SRC

** Git
*** Use =magit= to show git status

I use =magit= to show git status.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  ("C-x g" . magit)
  ("C-x C-g" . magit-file-dispatch)

  :custom
  ;; https://twitter.com/iLemming/status/1243322552828571649
  (magit-save-repository-buffers 'save-all-and-dont-ask)

  ;; sort branches (or any refs) by creation date
  (magit-list-refs-sortby "-creatordate")


  :config
  ;; so it don't close other windows
  (fset 'magit-restore-window-configuration (lambda (x) (kill-buffer-and-window)))
  ;; automatically refresh after saving a file
  ;;
  ;; Edit: I turned it off as it makes editing a bit laggy. Now please
  ;; press 'g' manually to refresh.
  ;;
  ;; (add-hook 'after-save-hook 'magit-after-save-refresh-status t)

  ;; do not override projectile keys
  (unbind-key "M-p" magit-status-mode-map)
  (unbind-key "M-n" magit-status-mode-map)

  ;; do not show list of tags to faster
  (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)

  ;; magit/transient uses some functions from emacs 28
  (when (< emacs-major-version 28)
    (defun length= (str n)
      (= (length str) n))
    (defun string-replace (old new s)
      (s-replace old new s))
    (defun string-search (needle haystack &optional start-pos)
      (s-contains? needle haystack)))

  ;; show exact date on revision page
  (setq magit-revision-headers-format (->> magit-revision-headers-format
                                           (s-replace "%ad" "%ad (%aD)")
                                           (s-replace "%cd" "%cd (%cD)")))
  )
#+END_SRC

*** Use =forge= for online features

Hotkey to remember:

| C-c C-o | forge-browse-topic |

#+BEGIN_SRC emacs-lisp
(use-package forge
  :after magit
  :bind (:map magit-mode-map
              ("M-W" . forge-copy-url-at-point-as-kill))
  :config
  ;; '(githost apihost id class)
  (add-to-list 'forge-alist
               '("git.lain.li"
                 "git.lain.li/api/v1"
                 "git.lain.li"
                 forge-gitea-repository))
  )
#+END_SRC

*** Ediff

#+begin_src emacs-lisp
(use-package ediff
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally)
)

#+end_src

*** Browse current file on GitHub

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :bind (("C-c g g" . browse-at-remote)
         ("C-c g G" . browse-at-remote-kill)
         ;; mimic "open-at-point" behaviour
         :map prog-mode-map
         ("C-c C-o" . browse-at-remote)))
#+END_SRC


*** Git time machine

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands git-timemachine)
#+END_SRC

*** Follow symbolic links without warning

#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC

*** Use =delta= to show better diff

Delta supports highlighting language-syntax, within-line diff, etc.

Install delta with the instruction here: https://github.com/dandavison/delta

#+begin_src emacs-lisp
(use-package magit-delta
  :if (executable-find "delta")
  :hook (magit-mode . magit-delta-mode))
#+end_src

** Dev docs
*** Search symbol at point in Dash with =C-c d=

#+BEGIN_SRC emacs-lisp
(use-package dash-at-point
  :if (eq system-type 'darwin)
  :bind (:map prog-mode-map
              ("C-c d" . dash-at-point)))
#+END_SRC

*** Query devdocs within Emacs

#+begin_src emacs-lisp
(use-package devdocs
  :bind
  ("C-h D" . devdocs-lookup)
  ("C-h d" . devdocs-lookup)
  ("C-c d" . shou/devdocs-at-point)

  :config
  (defun shou/devdocs-at-point ()
    (interactive)
    (if-let ((symbol (thing-at-point 'symbol 'no-properties)))
        (devdocs-lookup t symbol)
      (devdocs-lookup t)))
  )
#+end_src

** Completion and LSP (=M-/=)
*** Completion engine (corfu)

I now use corfu as my completion engine. Comparing to company, it's more modularized, providing richer feature via opt-in packages.

#+begin_src emacs-lisp
(use-package corfu
  :straight (corfu :files (:defaults "extensions/*")
                   :includes (corfu-info
                              corfu-directory
                              corfu-history
                              corfu-popupinfo))

  :bind
  (:map corfu-map
        ("C-SPC" . corfu-insert-separator))

  :hook
  (emacs-startup . global-corfu-mode)

  :custom
  ;; if the line is already indented, try complete instead
  (tab-always-indent 'complete)

  ;; enable auto completion
  (corfu-auto t)

  :config
  (use-package kind-icon
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
    (setq kind-icon-default-face 'corfu-default)
    (setq kind-icon-default-style
          '(:padding -1.1 :stroke 0 :margin 0 :radius 0 :height 0.4 :scale 1))
    )

  ;; enable corfu completion for eval-expession/shell-command
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
  )

;;
;; Helpful commands for debugging kind icon styles:

;; (insert (let ((kind-icon-default-style
;;                '(:padding -1 :stroke 0 :margin 0 :radius 0 :height 0.5 :scale 1.0)))
;;           (kind-icon-reset-cache)
;;           (kind-icon-formatted 'variable)))

;; (insert (propertize " " 'display `(space :width 10)))
;; (svg-lib-icon "variable"
;;               '(:padding -1 :stroke 0 :margin 0 :radius 0 :width 0.5 :height 0.5 :scale 0.5))

#+end_src

Configure corfu extensions:

#+begin_src emacs-lisp
(use-package corfu-history
  :after corfu
  :hook (corfu-mode . corfu-history-mode)
  :ensure nil
  :config
  (savehist-mode 1)
  (add-to-list 'savehist-additional-variables 'corfu-history)
  )
#+end_src

*** Extra completion

Add more completions to capf for corfu to consume:

#+begin_src emacs-lisp
(use-package cape
  :commands (shou/text-mode-completions)
  :demand t
  :bind
  ("M-/" . cape-dabbrev)

  :hook
  (text-mode . shou/text-mode-completions)

  :config
  ;; dabbrev is disabled because it's too noisy. Invoke with M-/ instead.
  ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-abbrev)

  (defun shou/text-mode-completions ()
    (make-local-variable 'completion-at-point-functions)
    ;; add to the end
    (add-to-list 'completion-at-point-functions #'cape-ispell t)
    )

  ;; c.f. https://github.com/minad/corfu#completing-in-the-eshell-or-shell
  (when (version< emacs-version "29")
    ;; Silence the pcomplete capf, no errors or messages!
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-function'.
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))
  )
#+end_src

*** Show docs on completion

I like to show documentation on the side of popup. Using the official extension corfu-popupinfo since corfu-doc is deprecated.

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :ensure nil
  :bind (:map corfu-map
              ;; Scroll in the documentation window
              ("M-n" . #'corfu-popupinfo-scroll-up)
              ("M-p" . #'corfu-popupinfo-scroll-down)
              ))
#+end_src

*** Completion style

Orderless allows completion to be filtered by typing space separated words. Similar to =prescience.el= but it doesn't sort the result.

#+begin_src emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides
   '(
     ;; TRAMP hostname completion requires "basic" style to work
     (file (styles basic partial-completion)))
   )
  ;; ignore case for filenames
  (read-file-name-completion-ignore-case t)
  )
#+end_src

*** Templating with tempel

Templating engine that allows me to quickly enter some text.

#+begin_src emacs-lisp
(use-package tempel
  :hook
  (text-mode . shou/add-tempel-to-capf)
  (prog-mode . shou/add-tempel-to-capf)

  :bind
  ("C-<tab>" . shou/tempel-expand-or-complete)

  (:map tempel-map
        ("<tab>" . tempel-next)
        ("<backtab>" . tempel-previous)
        ("S-<tab>" . tempel-previous))

  :custom
  ;; cannot be symlinked file because otherwise the auto-reload doesn't work.
  (tempel-path (f-canonical "~/.emacs.d/templates"))

  :config
  (defun shou/add-tempel-to-capf ()
    (make-local-variable 'completion-at-point-functions)
    (add-to-list 'completion-at-point-functions #'tempel-complete))


  ;; expand directly if there is an exact match, otherwise show candidates
  (defun shou/tempel-expand-or-complete ()
    (interactive)
    (if (tempel-expand)
        (tempel-expand t)
        (tempel-complete t)))

  (setq tempel-snippet-path (f-canonical "~/.emacs.d/snippets"))
  (defun shou/tempel-snippet (file)
    (f-read-text (f-join tempel-snippet-path file)))
  )
#+end_src


*** Support Language Server Protocols (LSP)

**** LSP mode

#+begin_src emacs-lisp
(use-package lsp-mode
  :straight (:host github :repo "emacs-lsp/lsp-mode")

  :init
  ;; to fix a weird bug
  (setq lsp-keymap-prefix "M-l")
  (add-to-list 'load-path (concat (straight--repos-dir) "lsp-mode/" "clients"))

  ;; see https://github.com/minad/corfu/wiki#basic-example-configuration-with-orderless
  (defun shou/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless))) ;; Configure orderless

  :commands (lsp lsp-mode lsp-deferred)
  :bind
  (:map lsp-mode-map
        ("C-c C-f" . lsp-format-buffer)
        ("M-," . xref-find-definitions)
        ("M-." . xref-find-definitions-other-window)
        )

  :bind-keymap
  ("M-l" . lsp-command-map)

  :custom
  ;; use Corfu!
  (lsp-completion-provider :none)

  ;; 1 sec or fail
  (lsp-response-timeout 1.0)

  ;; do not expect yasnippet is installed
  (lsp-enable-snippet nil)

  ;; place lens above a line instead at the end of a line
  (lsp-lens-place-position 'above-line)

  ;; performance tuning
  (read-process-output-max (* 1 1024 1024)) ;; 20mb

  ;; only sort by position
  (lsp-imenu-sort-methods '(position kind name))
  (lsp-imenu-show-container-name t)

  ;; do not show breadcrumb
  (lsp-headerline-breadcrumb-enable nil)

  ;; do not auto configure dap-mode unless I explicitly asked for it.
  ;; otherwise it starts dap-tooltip-mode which interfere with the corfu popup.
  (lsp-enable-dap-auto-configure nil)

  ;; only load clients that I actually need
  (lsp-client-packages
   '(lsp-elixir
     lsp-rust
     lsp-pylsp
     lsp-javascript
     lsp-json))

  :hook
  (lsp-completion-mode . shou/lsp-mode-setup-completion)

  :config
  ;; (use-package lsp-treemacs)

  ;; exclude watch files for elixir projects
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\.elixir_ls")
  (add-to-list 'lsp-file-watch-ignored "\\.beam\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]_build\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]deps\\'")

  ;; override default lsp-xref backend
  (add-hook 'lsp-mode-hook 'insert-dumb-jump-to-xref)

  (add-hook 'lsp-mode-hook 'lsp-enable-which-key-integration)

  ;; disable lsp-modeline-diagnostics-mode
  (add-hook 'lsp-mode-hook (lambda () (lsp-modeline-diagnostics-mode -1)))

  ;; conflict with projectile prefix
  (unbind-key "M-p" lsp-signature-mode-map)
  ;; unbind it as well as I never bother using it.
  (unbind-key "M-n" lsp-signature-mode-map)

  (use-package lsp-ui
    :custom
    (lsp-ui-doc-enable nil)
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-delay 0)
    )

  ;; fallback to dumb-jump if lsp can't find defn
  ;; copied from https://github.com/hlissner/doom-emacs/issues/4662#issuecomment-780911875
  (defun lsp-find-definition-or-dumb-jump ()
    (interactive)
    (let ((loc (lsp-request "textDocument/definition"
                            (lsp--text-document-position-params))))
      (if (seq-empty-p loc)
          (lsp-show-xrefs (lsp--locations-to-xref-items loc) nil nil)
        (dumb-jump-go))))

  ;; See https://github.com/minad/corfu/issues/188#issuecomment-1148658471
  (with-eval-after-load 'cape
    (advice-add #'lsp-completion-at-point :around #'cape-wrap-noninterruptible))

  (defun shou/add-lsp-next-checker (checker)
    (setq shou/flycheck-local-cache
          `((lsp . ((next-checkers . (,checker)))))))
  )
#+end_src

*** Debugger support (dap-mode)

#+begin_src emacs-lisp
(use-package dap-mode
  :commands (dap-debug dap-hydra)
  :config
  (dap-ui-mode)
  (dap-ui-controls-mode 1)

  (require 'dap-lldb)
  (require 'dap-gdb-lldb)
  (require 'dap-elixir)

  (dap-gdb-lldb-setup)

  (add-hook 'dap-stopped-hook
            (lambda (arg) (call-interactively #'dap-hydra)))

  (dap-tooltip-mode -1)
  )
#+end_src

*** Formatting code with apheleia

#+BEGIN_SRC emacs-lisp
(use-package apheleia
  :straight (:host github :repo "raxod502/apheleia")
  :config
  (add-to-list 'apheleia-formatters '(mix . ("mix" "format" "-")))
  (add-to-list 'apheleia-formatters '(prettier . (npx "prettier" "--stdin-filepath" filepath)))
  (add-to-list 'apheleia-formatters '(rustfmt . ("rustfmt" "--quiet" "--emit" "stdout")))

  (add-to-list 'apheleia-mode-alist '(elixir-mode . mix))

  ;; See https://github.com/raxod502/apheleia/issues/30
  (defun shou/fix-apheleia-project-dir (orig-fn &rest args)
    (let ((project (project-current)))
      (if (not (null project))
          (let ((default-directory (projectile-project-root))) (apply orig-fn args))
        (apply orig-fn args))))

  (advice-add 'apheleia-format-buffer :around #'shou/fix-apheleia-project-dir)

  ;; sometimes apheleia erase the whole buffer, which is pretty annoying.
  ;; fix it by detecting this scenario and simply doing no-op
  (defun shou/fix-apheleia-accidental-deletion
      (orig-fn old-buffer new-buffer &rest rest)
    (if (and (=  0 (buffer-size new-buffer))
             (/= 0 (buffer-size old-buffer)))
        ;; do not override anything
        nil
        (apply orig-fn old-buffer new-buffer rest)))

  (advice-add 'apheleia--create-rcs-patch :around #'shou/fix-apheleia-accidental-deletion)

  ;; used in hooks to turn off apheleia mode for some modes
  (defun shou/disable-apheleia-mode nil (apheleia-mode -1))

  (apheleia-global-mode 1))
#+END_SRC

** Typos

#+begin_src emacs-lisp
;; (use-package typos-mode
;;   :after flycheck
;;   :straight (:host nil :repo "/home/shou/projects/typos-mode/.git")
;;   :config
;;   (add-hook 'prog-mode-hook 'typos-mode)
;; )
#+end_src

** Compile mode configurations

#+begin_src emacs-lisp
(setq compilation-scroll-output 'first-error)

;; colorize using ansi color
(require 'ansi-color)
(add-hook 'compilation-filter-hook
          (lambda ()
            (let ((inhibit-read-only t))
              (ansi-color-apply-on-region compilation-filter-start (point)))))
#+end_src

** Tree sitter

#+begin_src emacs-lisp
(use-package tree-sitter
  :config
  (use-package tree-sitter-langs)
  (global-tree-sitter-mode +1)
  ;; tree-sitter-hl-mode doesn't work good with rust-mode on some new
  ;; syntax (e.g. let..else), disabling for now.

  ;; (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
  )
#+end_src

** Languages
*** C/C++

The default C style determines the style of a number of modes.

#+begin_src emacs-lisp
;; Set the default label indentation to 2 (from 1). this affects the
;; indentation in front of "int x" in the example.
;;
;; struct foo {
;;   int x
;; ...
;;
(with-eval-after-load 'cc-vars
  (setf (alist-get 'c-label-minimum-indentation c-fallback-style) 2))
#+end_src

*** Lisps
**** Use =paredit= in lisp modes to balance parentheses

I customized several bindings because "C-<left>/<right>" is bound to
"previous/next desktop" on my macOS.

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :commands paredit-mode
  :hook (lisp-mode-map-hook . paredit-mode)
  :bind (:map paredit-mode-map
              ;; ((a|) b) => ((a| b))
              ("M-<right>" . paredit-forward-slurp-sexp)
              ;; ((a| b)) => ((a|) b)
              ("M-<left>" . paredit-forward-barf-sexp)
              ;; (a (|b)) => ((a |b))
              ("M-S-<left>" . paredit-backward-slurp-sexp)
              ;; ((a |b)) => (a (|b))
              ("M-S-<right>" . paredit-backward-barf-sexp)
              ;; ((a|) b) => (a| b)
              ("M-<down>" . paredit-splice-sexp)
              ;; (|a b) => ((a) b)
              ("M-<up>" . paredit-wrap-sexp)
              ;; (|a b) => ((a) b)
              ("M-(" . paredit-wrap-round)))
#+END_SRC

**** Use =rainbow-delimiters=

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

**** Enable above two modes for all lisp languages

#+BEGIN_SRC emacs-lisp
(dolist (hook '(clojure-mode-hook
                emacs-lisp-mode-hook
                scheme-mode-hook
                racket-mode-hook
                cider-repl-mode-hook
                lisp-mode-hook))
  (add-hook hook 'paredit-mode)
  (add-hook hook 'rainbow-delimiters-mode))
#+END_SRC

**** Shorten =Emacs lisp= into =Elisp= in mode name

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook (lambda () (setq-default mode-name "Elisp")))
#+END_SRC

**** Use =eldoc= to display documentation

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :config
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+END_SRC

**** Highlight info documentations

Colorize function names/arguments in info documentations.

#+BEGIN_SRC emacs-lisp
(use-package info-colors
  :config (add-hook 'Info-selection-hook 'info-colors-fontify-node))
#+END_SRC

**** Parinfer

#+begin_src emacs-lisp
(use-package parinfer-rust-mode
  :straight (:host github :repo "justinbarclay/parinfer-rust-mode" :branch "main")
  ;; disabled for now because it's making helpful-mode slow at loading
  ;; up the source code
  :disabled
  )
#+end_src

**** Eval elisp within emacs

Use pretty eval expression by default because it prints the full output when overflows.

#+begin_src emacs-lisp
(bind-key "M-:" #'pp-eval-expression)
#+end_src

*** Elixir
**** Use =elixir-mode= for highlighting

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :mode (("\\.exs\\'" . elixir-mode)
         ("\\.ex\\'" . elixir-mode))

  ;; Format with C-c C-f
  :bind (:map elixir-mode-map
              ("M-q" . python-fill-paragraph))
  :hook (elixir-mode . lsp)

  :config
  ;; we don't enable eglot's auto completion functionality
  (add-hook 'elixir-format-hook
            (lambda ()
              (if (projectile-project-p)
                  (setq elixir-format-arguments
                        (list "--dot-formatter"
                              (concat (locate-dominating-file buffer-file-name ".formatter.exs") ".formatter.exs")))
                (setq elixir-format-arguments nil))))

  (require 'python)

  ;; this hack to make it work with multiline strings.
  (setq python-fill-docstring-style 'django)
  (defun shou/always-docstring () t)
  (defun shou/pretend-python-mode (fun &rest xs)
    (let ((old-major-mode major-mode)
          (always-docstring (lambda () t)))
      (advice-add 'python-info-docstring-p :override #'shou/always-docstring)
      (python-mode)
      (apply fun xs)
      (advice-remove 'python-info-docstring-p #'shou/always-docstring)
      (funcall old-major-mode)))
  (advice-add 'python-fill-string :around #'shou/pretend-python-mode)

  ;; used by templating engines
  (defun shou/elixir-module-name-for-file (file)
      (--> file
           (f-relative it (or (locate-dominating-file it "lib")
                              (locate-dominating-file it "test")))
           (f-no-ext it)
           (f-split it)
           (cdr it)
           (mapcar 's-upper-camel-case it)
           (s-join "." it)
       ))

  ;; enable elixir-credo after lsp
  (require 'lsp)
  (add-hook 'elixir-mode-hook (lambda () (shou/add-lsp-next-checker 'elixir-credo)))
  )
#+END_SRC

**** Run ExUnit
#+BEGIN_SRC emacs-lisp
(use-package exunit
  :after elixir-mode
  :bind (:map elixir-mode-map
              ("C-c C-t" . exunit-transient))
  :bind (:map projectile-command-map
              ;; override projectile-toggle-between-implementation-and-test
              ("t" . shou/toggle-elixir-file-and-test))
  :custom (exunit-environment '("MIX_ENV=test"))
  :config
  (defun shou/elixir-project-root ()
    (or (locate-dominating-file default-directory "apps")
        (locate-dominating-file default-directory "mix.exs")))
  (defun shou/set-exunit-project-root ()
    (setq exunit-project-root (shou/elixir-project-root)))
  (add-hook 'exunit-compilation-mode-hook #'shou/set-exunit-project-root)
  (advice-add 'exunit-project-root :override 'shou/elixir-project-root)

  (defun shou/disable-line-move-visual ()
    (interactive)
    (setq-local line-move-visual nil))
  (add-hook 'exunit-compilation-mode-hook #'shou/disable-line-move-visual)

  (defun shou/toggle-elixir-file-and-test ()
    (interactive)
    (progn
      (let ((curr-file (buffer-file-name)))
        (exunit-toggle-file-and-test)
        (when (equal curr-file (buffer-file-name))
          ;; if not switched, fallback to projectile
          (projectile-toggle-between-implementation-and-test)
          )))))
#+END_SRC

**** Alchemist

Press 'g' in compile mode to rerun last command (original 'r').

#+begin_src emacs-lisp
(use-package alchemist
  :after elixir-mode
  :disabled
  :hook (elixir-mode . alchemist-mode)

  :bind (:map alchemist-mode-map
              ("C-c C-c C-c" . alchemist-mix-compile)
              ("C-c C-c C-t" . alchemist-mix-test)
         :map alchemist-mix-mode-map
              ("g" . alchemist-mix-rerun-last-task))

  :init
  (setq alchemist-key-command-prefix (kbd "C-c C-a"))

  :custom
  (alchemist-mix-env "test")

  :config
  ;; conflicts with dumb-jump-go
  (unbind-key "M-." alchemist-mode-map)
  (unbind-key "M-," alchemist-mode-map)

  ;; respect alchemist-mix-env in iex-project
  (advice-add 'alchemist-iex-command
              :filter-return
              (lambda (ret) (append
                             (list "env" (concat "MIX_ENV=" alchemist-mix-env))
                             ret)))
  )
#+end_src

**** DAP debugger for exunit tests

#+begin_src emacs-lisp
(use-package dap-mode
  :commands (dap-exunit-here)
  :config
  (require 'dap-elixir)

  (defun shou/exunit-test-at-point ()
    (let* ((root (shou/elixir-project-root))
           (filename (buffer-file-name))
           (line (line-number-at-pos))
           (rel-filename (f-relative filename root)))
      (format "%s:%d" rel-filename line)))

  (defun shou/add-dap-template-this-exunit-test ()
    (interactive)
    (dap-register-debug-template
     (format "Elixir::Test at %s" (shou/exunit-test-at-point))
     (list :type "Elixir"
           :cwd nil
           :request "launch"
           :program nil
           :projectDir (f-expand (shou/elixir-project-root))
           :task "test"
           :taskArgs (list (shou/exunit-test-at-point))
           :name "Elixir::Test at point"))
    )
  )
#+end_src

**** Inferior iex session

#+begin_src emacs-lisp
(use-package inf-iex
  :straight (inf-iex :type git
                  :host github
                  :repo "DogLooksGood/inf-iex")
  :hook (elixir-mode . inf-iex-minor-mode)
  :bind
  (:map inf-iex-minor-mode-map
        ("C-c C-c" . inf-iex-eval)
        ("C-c C-v" . inf-iex-toggle-send-target)
        ("C-c C-b" . shou/inf-iex-send-buffer)
        )

  :config
  (defun shou/inf-iex-send-buffer ()
    (interactive)
    (inf-iex--send (buffer-string))
    )
  )
#+end_src

*** Protobuf

Simply install protobuf mode. Default settings should work.

#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :commands protobuf-mode
  :mode "\\.proto\\'"
  :mode "\\.proto3\\'"
  :hook (protobuf-mode . insert-dumb-jump-to-xref)
  )
#+END_SRC

*** JSON

Install JSON mode.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :commands json-mode
  :mode "\\.json\\'")
#+END_SRC

Reformatting JSON.

#+BEGIN_SRC emacs-lisp
(use-package json-reformat
  :after json-mode
  :functions json-reformat-format
  :custom (json-reformat:indent-width 2)
  :config
  (define-key json-mode-map (kbd "M-F")
    (lambda () (interactive) (mark-whole-buffer) (json-reformat-format))))
#+END_SRC

*** Rust

**** Rust mode

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode)
  :custom
  ;; do not show a buffer for format errors
  (rust-format-show-buffer nil)

  ;; set default indent size to 2. Actual indent size will be auto-detected
  (rust-indent-offset 2)

  ;; enable proc macro expansion for rust-analyzer (used by lsp mode)
  (lsp-rust-analyzer-proc-macro-enable t)

  ;; default: "check".
  (lsp-rust-analyzer-cargo-watch-command "clippy")

  ;; enable clippy by default
  (lsp-rust-clippy-preference "on")

  ;; show variable types as inlay hints
  (lsp-rust-analyzer-server-display-inlay-hints nil)

  :bind
  (:map rust-mode-map
        ("C-c C-c C-e" . lsp-rust-analyzer-open-cargo-toml))

  :config
  ;; enable LSP for type info and more
  (add-hook 'rust-mode-hook #'lsp)

  ;; fix incorrect filename regexp in compilation mode
  ;; See https://github.com/rust-lang/rust-mode/issues/452
  (setq error_stack-regexps
        '("\\(?:at\\|',\\) \\(\\([^:\s]+\\):\\([0-9]+\\)\\)"
          2 3 nil nil 1))
  (setf (cdr (assoc 'cargo compilation-error-regexp-alist-alist)) error_stack-regexps))
#+END_SRC

**** Cargo commands

#+begin_src emacs-lisp
(use-package cargo
  :bind
  (:map cargo-minor-mode
        ("C-c C-c r" . cargo-process-run-release)
        ("C-c C-c C-r" . cargo-process-run)
        ("C-c C-c C-c" . cargo-process-check)
        ("C-c C-c C-k" . cargo-process-clippy)
        ("C-c C-c C-a" . cargo-process-add)
        ("C-c C-c C-f" . cargo-process-fmt))

  :hook
  (rust-mode . cargo-minor-mode)
  (conf-toml-mode . cargo-minor-mode)

  :custom
  ;; show backtrace in cargo-run
  (cargo-process--enable-rust-backtrace t)
  (cargo-process--command-watch "watch -q --clear -x run")

  :config
  (defun cargo-process-run-release ()
    (interactive)
    (let ((cargo-process--command-run "run --release"))
      (cargo-process-run))))

;; avoid conflict with cargo mode
(with-eval-after-load 'conf-mode
  (unbind-key "C-c C-c" conf-mode-map))
#+end_src

**** Other rust related packages

Rusty Object Notation (RON) mode:

#+begin_src emacs-lisp
(use-package ron-mode :mode "\\.ron\\'")
#+end_src

*** Shell

#+BEGIN_SRC emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            ;; to use shellcheck as lint software
            (flycheck-mode)
            ;; these variables sometimes get reset when opening a shell file, so
            ;; I manually set them here.
            (setq sh-basic-offset 2
                  sh-indentation 2)))
#+END_SRC

*** Dockerfile

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile")
(use-package docker-compose-mode
  :mode "docker-compose\\.ya?ml"
  :mode "fig\\.ya?ml")
#+END_SRC

*** Terraform

#+BEGIN_SRC emacs-lisp
(use-package terraform-mode
  :mode "\\.tf\\'")
#+END_SRC

*** Web

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode ("\\.html?\\'"
         "\\.tsx\\'"
         "\\.jsx\\'"
         "\\.ts\\'"
         "\\.js\\'")
  :custom
  (web-mode-css-indent-offset 2)
  (web-mode-markup-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-enable-css-colorization t)
  (web-mode-enable-auto-pairing t)
  (web-mode-enable-comment-keywords t)
  (web-mode-enable-current-element-highlight t)
  (web-mode-enable-auto-quoting nil)
  :config
  (with-eval-after-load 'lsp-mode
    ;; fix lsp incorrect indentation: https://github.com/emacs-lsp/lsp-mode/issues/2915
    (setf (alist-get 'web-mode lsp--formatting-indent-alist) 'web-mode-code-indent-offset)
    )
  )
#+END_SRC

*** Systemd unit files

#+BEGIN_SRC emacs-lisp
(use-package systemd
  :if (eq 'system-type 'gnu/linux)
  :mode (("\\.service\\'" . systemd-mode)
         ("\\.timer\\'" . systemd-mode)
         ("/etc/systemd/.*\\.conf\\'" . systemd-mode)))
#+END_SRC

*** Ansible

#+BEGIN_SRC emacs-lisp
(defun ansible-vault-mode-maybe ()
  (when (ansible-vault--is-vault-file)
    (ansible-vault-mode 1)))

(use-package ansible-vault
  :commands (ansible-vault--is-vault-file ansible-vault-mode)
  :hook (yaml-mode . ansible-vault-mode-maybe))

(use-package jinja2-mode
  :mode ("\\.hs\\'" . jinja2-mode))
#+END_SRC

*** Haskell

**** Haskell mode

I use haskell mode for syntax highlighting, indentation, and a variety of
project related functionalities.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :bind (:map haskell-mode-map
              ("C-c C-c" . haskell-compile)
              ("C-c `" . haskell-interactive-bring)
              ("C-c C-l" . haskell-process-load-or-reload)
              ("C-c C-t" . haskell-process-do-type)
              ("C-c C-i" . haskell-process-do-info)
              ("M-." . haskell-mode-jump-to-def))
  :hook (haskell-mode . shou/disable-apheleia-mode)
  :mode (("\\.hs\\'" . haskell-mode))
  :custom
  ;; build with "stack build"
  (haskell-compile-cabal-build-command "stack build")
  ;; do not show error in a popup window
  (haskell-interactive-popup-errors nil)
  ;; show logs
  (haskell-process-log t)
  ;; auto load imports
  (haskell-process-auto-import-modules t)
)
#+END_SRC

**** LSP

#+begin_src emacs-lisp
(use-package lsp-haskell
  :disabled
  :hook (haskell-mode . lsp)
  :hook (haskell-literate-mode . lsp))
#+end_src

*** Idris

#+BEGIN_SRC emacs-lisp
(use-package idris-mode
  :after popwin
  :commands idris-mode
  :config
  ;; (add-to-list 'popwin:special-display-config 'idris-compiler-notes-mode)
  (add-to-list 'popwin:special-display-config
               '(idris-info-mode :stick t))
  (add-to-list 'popwin:special-display-config
               '(idris-repl-mode :height 0.2
                                 :noselect nil
                                 :position bottom
                                 :stick t)))

(use-package idris2-mode
  :after popwin
  :straight (:host github :repo "jeroendehaas/idris2-mode")
  :commands idris2-mode
  :mode "\\.idr\\'"
  :config
  (add-to-list 'popwin:special-display-config
               '(idris2-compiler-notes-mode :noselect t))
  (add-to-list 'popwin:special-display-config
               '(idris2-repl-mode :height 0.2
                                 :noselect nil
                                 :position bottom
                                 :stick t))
  )
#+END_SRC

*** Python

#+begin_src emacs-lisp
(use-package python
  :straight (:type built-in)
  :commands (python-fill-paragraph)
  :custom
  (python-shell-completion-native-enable nil)
  )
#+end_src

*** Kubernetes

K8s mode for editing yaml files.

#+begin_src emacs-lisp
(use-package k8s-mode
  :defer t
  :magic "apiVersion"
  ;; match all yaml files beneath a folder named "kustom*"
  :mode "/kustom.*ya?ml\\'"
  )
#+end_src

Kubernetes.el for managing k8s cluster.

#+begin_src emacs-lisp
(use-package kubernetes
  :commands (kubernetes-overview))
#+end_src

*** JavaScript

#+begin_src emacs-lisp
(use-package js2-mode
  :mode "\\.js\\'"
  :hook (js2-mode . lsp)
  :config
  (setq-default js2-indent-level 2)
  (setq-default js2-basic-offset 2)
  (unbind-key "C-c C-f" js2-mode-map)
  )
#+end_src

*** TypeScript

#+begin_src emacs-lisp
(use-package tide
  :after web-mode
  :config
  (defun shou/setup-tide-mode ()
    "Set up Tide mode."
    (interactive)
    (when (or (string-equal "jsx" (file-name-extension buffer-file-name))
              (string-equal "tsx" (file-name-extension buffer-file-name))
              (string-equal "ts" (file-name-extension buffer-file-name)))
      (lsp-deferred)
      (tide-setup)))
  (with-eval-after-load 'web-mode
    (add-hook 'web-mode-hook #'shou/setup-tide-mode))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (flycheck-add-next-checker 'javascript-eslint 'jsx-tide 'append))
#+end_src

*** PHP

#+begin_src emacs-lisp
(use-package php-mode :mode "\\.php\\'")
#+end_src

*** Prolog

#+begin_src emacs-lisp
(use-package prolog
  :mode (("\\.pl\\'" . prolog-mode)
         ("\\.plt\\'" . prolog-mode)))
#+end_src

*** Coq

#+begin_src emacs-lisp
(use-package proof-general
  :mode ("\\.v\\'" . coq-mode)

  :init
  ;; do not display splash screen
  (setq proof-splash-enable nil)

  :custom
  ;; do not stuck on comments.
  (proof-script-fly-past-comments t)
  (proof-three-window-mode-policy 'hybrid)
  )

(with-eval-after-load 'coq-mode
  (defun shou/coq-mode-settings ()
    ;; disable built-in abbrev completions which are pretty annoying.
    (abbrev-mode -1)
    (clear-abbrev-table coq-mode-abbrev-table)
    (define-abbrev coq-mode-abbrev-table "ref" "reflexivity")
    (define-abbrev coq-mode-abbrev-table "discr" "discriminate")
    (define-abbrev coq-mode-abbrev-table "gd" "generalize dependent")
    (abbrev-mode 1)
    )

  (add-hook 'coq-mode-hook #'shou/coq-mode-settings 100)

  (defun shou/enable-company-coq ()
	  (company-coq-mode +1)
	  (company-mode -1)

    ;; a hack to prevent company-coq-master-backend from inserting an
    ;; extra newline.
    (fset #'company-coq-post-completion-master #'ignore)

	  (setq-local completion-at-point-functions
		            (append
                 (mapcar #'cape-company-to-capf
		                     (list #'company-coq-math-symbols-backend
				                       #'company-coq-choices-backend
				                       #'company-coq-master-backend))
		             completion-at-point-functions)))

  (add-hook 'coq-mode-hook #'shou/enable-company-coq)

  ;; Coq mode completion:
  ;;
  ;; putting it under proof-general because it loads company-mode and
  ;; yasnippet which I don't currently use. I will only load it when
  ;; necessary.
  (use-package company-coq
    :commands company-coq-mode
    :custom
    (company-coq-disabled-features
     '(;; disabling it makes evaluation much faster.
       alerts
       ;; I don't need it. It's pretty annoying and sometimes misbehaves.
       code-folding
       ;; spinner somehow caused the processing too slow.
       spinner
       ))

    ;; load symbols and tactics defined externally
    (company-coq-live-on-the-edge t)))
#+end_src

*** Racket

#+begin_src emacs-lisp
(let ((racket-paths (f-glob "/Applications/Racket */bin")))
  (when (> (length racket-paths) 0)
    (add-to-list 'exec-path (car racket-paths))))

(use-package racket-mode
  :mode ("\\.rkt\\'" . racket-mode)
  :hook (racket-mode . lsp)
  :config
  ;; not sure why but this module doesn't autoload
  (require 'lsp-racket)
  )
#+end_src

*** Shader languages

GLSL:

#+begin_src emacs-lisp
(use-package glsl-mode
  :mode ("\\.glsl\\'" "\\.vert\\'" "\\.frag\\'"))
#+end_src

WGSL:

#+begin_src emacs-lisp
(use-package wgsl-mode
  :straight (:host github :repo "acowley/wgsl-mode")
  :mode ("\\.wgsl\\'"))
#+end_src

*** Clojure

#+begin_src emacs-lisp
(use-package clojure-mode
  :mode ("\\.clj\\'" "\\.cljs\\'")
  :config
  (use-package cider)
  )
#+end_src

*** Perl and Raku

#+begin_src emacs-lisp
(use-package raku-mode
  :mode ("\\.raku\\'"))
#+end_src

*** eww and yuck

#+begin_src emacs-lisp
(use-package lisp-mode
  :ensure nil
  :straight nil
  :mode ("\\.yuck\\'"))
#+end_src

*** Python

#+begin_src emacs-lisp
(use-package python-mode
  :straight nil
  :mode ("\\.py\\'" . python-mode)
  :custom
  (python-shell-interpreter "ipython")
  (python-shell-interpreter-args "--simple-prompt -i")
  )
#+end_src

* AI

** copilot.el

#+begin_src emacs-lisp
(use-package copilot
  :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
  :commands (copilot-mode copilot-clear-overlay copilot-complete)
  :custom
  ;; enable logging (max size: 1000)
  (copilot-log-max 1000)
  (copilot-idle-delay 0.3)

  :bind
  ;; C-S-tab
  (("C-<iso-lefttab>" . copilot-complete)
   :map copilot-completion-map
   ("C-e" . copilot-accept-completion)
   ("M-f" . copilot-accept-completion-by-word)
   ("C-g" . copilot-clear-overlay)
   )

  :hook
  (text-mode . copilot-mode)
  (prog-mode . copilot-mode)

  :config
  (defun shou/copilot-disable-predicate nil
    (or
     ;; do not enable copilot when i'm editing wiki
     (derived-mode-p 'mediawiki-mode)
     ;; do not enable copilot on files that may contain secrets
     (string-match-p "\\(?:secret\\|cred\\|hidden\\|private\\)" (buffer-name))))
  (add-to-list 'copilot-disable-predicates #'shou/copilot-disable-predicate))
#+end_src

** Ancilla

#+begin_src emacs-lisp
(use-package ancilla
  :straight (:local-repo "~/projects/ancilla")
  :bind ("C-x C-r" . shou/ancilla-generate-or-rewrite)
  :config
  (setq ancilla-adaptor-chat-openai-api-key
        (shou/get-pass-entry "openai/api-key"))

  (defun shou/ancilla-generate-or-rewrite (arg)
    "Generate or rewrite text using GPT-3.5-turbo or GPT-4 based on the prefix argument.
With a prefix argument (C-u), use GPT-4. Otherwise, use GPT-3.5-turbo."
    (interactive "P")
    (cond
     (arg
      (let ((ancilla-adaptor-chat-model "gpt-4"))
        (ancilla-generate-or-rewrite)))
     (t
      (let ((ancilla-adaptor-chat-model "gpt-3.5-turbo"))
        (ancilla-generate-or-rewrite)))))
  )
#+end_src

** ChatGPT shell

#+begin_src emacs-lisp
(use-package chatgpt-shell
  :straight (:host github :repo "xenodium/chatgpt-shell")
  :commands (chatgpt-shell-explain-code chatgpt-shell)
  :custom
  (chatgpt-shell-chatgpt-streaming t)
  :config
  (setq chatgpt-shell-openai-key (shou/get-pass-entry "openai/api-key")))
#+end_src

* Org mode

#+BEGIN_SRC emacs-lisp
(use-package org)
#+END_SRC

** Set org directory

#+BEGIN_SRC emacs-lisp
(setq-default org-directory "~/Documents/org")

(defun org-file-path (filename)
  "Return the path of file inside org-directory"
  (expand-file-name filename org-directory))

(use-package org
  :custom (org-default-notes-file (org-file-path "notes.org")))
#+END_SRC

** Behavior tweaks


#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  ;; for org-indent-mode
  (org-indent-indentation-per-level 1)
  ;; do not automatically ident based on heading
  (org-adapt-indentation nil)

  ;; make TAB acts as in major mode
  (org-src-tab-acts-natively t)

  ;; Avoid inadvertent text edit in invisible area
  (org-catch-invisible-edits 'show-and-error)

  ;; Hide empty lines between subtrees in collapsed view
  (org-cycle-separator-lines 0)

  ;; use these set of bullets
  (org-list-demote-modify-bullet '(("+" . "-") ("-" . "+")))

  ;; increase the depth that imenu can reach
  (org-imenu-depth 3)

  ;; use cookies like <width> to define width for columns
  (org-startup-shrink-all-tables t)

  :config
  ;; We enable org-indent-mode to make contents align with their settings
  (add-hook 'org-mode-hook 'org-indent-mode)

  ;; turn on abbrev mode
  (add-hook 'org-mode-hook 'abbrev-mode)

  ;; add company completion backend
  ;; (defun add-org-completion-backend ()
  ;; (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
  ;; (add-hook 'org-mode-hook 'add-org-completion-backend)

  ;; do not insert blank line after new list items on M-Ret
  (setcdr (assoc 'plain-list-item org-blank-before-new-entry) nil)
  )
#+END_SRC

Reference: [[https://yiufung.net/post/org-mode-hidden-gems-pt1/#avoid-inadvertent-text-edit-in-invisible-area][Org-mode Hidden Gems - 01 Document Structure]]

*** Patch a buggy function with native compile

This function has issue with native-comp, so I'll define it here to ensure the content isn't native compiled. I know it's hacky but can't think of better way to do it (easy & without losing much performance).

#+begin_src emacs-lisp
(defun org-offer-links-in-entry (buffer marker &optional nth zero)
  "Offer links in the current entry and return the selected link.
If there is only one link, return it.
If NTH is an integer, return the NTH link found.
If ZERO is a string, check also this string for a link, and if
there is one, return it."
  (with-current-buffer buffer
    (org-with-wide-buffer
     (goto-char marker)
     (let ((cnt ?0)
           have-zero end links link c)
       (when (and (stringp zero) (string-match org-link-bracket-re zero))
         (push (match-string 0 zero) links)
         (setq cnt (1- cnt) have-zero t))
       (save-excursion
         (org-back-to-heading t)
         (setq end (save-excursion (outline-next-heading) (point)))
         (while (re-search-forward org-link-any-re end t)
           (push (match-string 0) links))
         (setq links (org-uniquify (reverse links))))
       (cond
        ((null links)
         (message "No links"))
        ((equal (length links) 1)
         (setq link (car links)))
        ((and (integerp nth) (>= (length links) (if have-zero (1+ nth) nth)))
         (setq link (nth (if have-zero nth (1- nth)) links)))
        (t            ; we have to select a link
         (save-excursion
           (save-window-excursion
             (delete-other-windows)
             (with-output-to-temp-buffer "*Select Link*"
               (dolist (l links)
                 (cond
                  ((not (string-match org-link-bracket-re l))
                   (princ (format "[%c]  %s\n" (cl-incf cnt)
                                  (org-unbracket-string "<" ">" l))))
                  ((match-end 2)
                   (princ (format "[%c]  %s (%s)\n" (cl-incf cnt)
                                  (match-string 2 l) (match-string 1 l))))
                  (t (princ (format "[%c]  %s\n" (cl-incf cnt)
                                    (match-string 1 l)))))))
             (org-fit-window-to-buffer (get-buffer-window "*Select Link*"))
             (message "Select link to open, RET to open all:")
             (setq c (read-char-exclusive))
             (and (get-buffer "*Select Link*") (kill-buffer "*Select Link*"))))
         (when (equal c ?q) (user-error "Abort"))
         (if (equal c ?\C-m)
             (setq link links)
           (setq nth (- c ?0))
           (when have-zero (setq nth (1+ nth)))
           (unless (and (integerp nth) (>= (length links) nth))
             (user-error "Invalid link selection"))
           (setq link (nth (1- nth) links)))))
       (cons link end)))))
#+end_src

*** Insert heading at cursor

aka. disabling the feature that "smartly" insert heading after the current subtree.

#+begin_src emacs-lisp
(use-package org
  :bind
  (:map org-mode-map
        ("C-<return>" . org-insert-heading)))
#+end_src


** Visual Tweaks
*** Turn on native source fontification in org buffer

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-src-fontify-natively t))
#+END_SRC

*** Hide leading stars

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-hide-leading-stars t))
#+END_SRC

*** Hide mark-up symbols

I'd like to hide ===, =+=, =*= symbols when not necessary.

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-hide-emphasis-markers t))
#+END_SRC

*** Customize wrap around symbol

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-ellipsis "…"))
#+END_SRC

*** Allow in safe variables

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (put 'org-pretty-entities 'safe-local-variable #'booleanp))
#+end_src

** Source editing
*** Do not add indentation from org-src-edit

See [[https://emacs.stackexchange.com/questions/18877/how-to-indent-without-the-two-extra-spaces-at-the-beginning-of-code-blocks-in-or][reference]].

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-src-strip-leading-and-trailing-blank-lines t)
  (org-src-preserve-indentation t))
#+END_SRC

*** Use the same window for org-src-edit

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-src-window-setup 'current-window))
#+END_SRC

*** Include emacs-lisp src quickly

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (dolist (shortcut (list '("el" . "src emacs-lisp")
                          '("sc" . "src scheme :session :results list")))
    (add-to-list 'org-structure-template-alist shortcut))

  (require 'org-tempo))
#+END_SRC

** To-do settings
*** Log down time when marking an item "DONE"

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-log-done 'time)
  (org-log-into-drawer t))
#+END_SRC
*** Customize colors

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-todo-keyword-faces
   '(("TODO" . "#a6b255")
     ("IN-PROG" . "#f2f9c1")
     ("TOREAD" . "#879434")
     ("WAIT" . "#c07993"))))
#+END_SRC
*** Enforce todo dependencies

Make todos respect blocking state.

#+begin_src emacs-lisp
(use-package org
  :config
  ; (setq org-enforce-todo-dependencies t)
  (setq org-agenda-dim-blocked-tasks 'invisible)
  )
#+end_src

** Taking note with =deft=

=deft.el= provides National Velocity-like note browsing and editing experience.

#+BEGIN_SRC emacs-lisp
(use-package deft
  :bind ("C-M-n" . deft)
  :commands (deft)
  :custom
  (deft-extensions '("org" "txt" "md" "markdown"))
  (deft-directory (org-file-path "random"))
  (deft-default-extension "org" "use org as default format")
  (deft-recursive t "search recursively")
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t "instead of some generated gibberish")
  (deft-auto-save-interval 60
    "don't auto save as it will reformat in middle of typing")
  (deft-file-naming-rules
    '((noslash . "-")
      (nospace . "-")
      (case-fn . downcase))
    "apply certain rules when generating file name")
  (deft-file-limit 40)
  )
#+END_SRC

** Org protocol

#+begin_src emacs-lisp
(use-package org
  :defer t
  :config
  (require 'org-protocol))
#+end_src

** Anki deck

#+BEGIN_SRC emacs-lisp
(defun shou/interactive-push-anki-notes ()
  (interactive)
  (when (and (eq major-mode 'org-mode)
             (not (equal "anki-cards-archive" (f-base buffer-file-name)))
             (> (length (anki-editor-map-note-entries t nil 'file)) 0)
             (yes-or-no-p "Push cards to Anki?"))
    (let ((progress-reporter
           (make-progress-reporter "Pushing cards to Anki..." nil nil)))
      (anki-editor-push-notes)
      (progress-reporter-done progress-reporter))))

(use-package anki-editor
  :disabled
  :after org
  :commands (anki-editor-push-notes
             anki-editor-map-note-entries
             anki-editor-insert-note
             anki-editor-mode)
  :hook (before-save . shou/interactive-push-anki-notes)
  :custom
  (anki-editor-org-tags-as-anki-tags t)
  (anki-editor-protected-tags '("marked" "leech" "relearn-experiment"))
  :config
  (setq anki-editor--ox-anki-html-backend 'ascii))
#+END_SRC

** Agenda
*** Use =C-c a= to enter agenda mode

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind ("C-c a" . org-agenda))
#+END_SRC

*** Set agenda files

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-agenda-files (list (org-file-path "projects.org")
                          (org-file-path "mencti.org"))))
#+END_SRC

*** Extend toady to 3am into next morning

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-extend-today-until 3)
  (org-use-effective-time t))
#+END_SRC

*** Agenda view

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  ;; show agenda on the same window I launched it, otherwise it destroys my dedicated window setting
  (org-agenda-window-setup 'current-window)
  ;; do not start on weekdays
  (org-agenda-start-on-weekday nil)
  ;; do not show repeating items in future timeline
  (org-agenda-show-future-repeats t)

  (org-agenda-sorting-strategy
   '((agenda category-keep habit-up priority-down todo-state-up time-up)
     (todo priority-down category-keep)
     (tags priority-down category-keep)
     (search priority-down category-keep)))

  (org-agenda-compact-blocks t)

  (org-agenda-span 'day)

  ;; skip filename as it takes up precious space and useless
  (org-agenda-prefix-format '((agenda . " %i  %?-12t% s")
                              (todo . " %i %-12:c")
                              (tags . " %i %-12:c")
                              (search . " %i %-12:c")))

  (org-agenda-custom-commands
   '(("d" "Daily agenda"
      ((agenda "" ((org-agenda-span 'day)))
       (todo "IN-PROG")))

     ("w" "Today's work agenda"
      ;; Please note that tags must go earlier than agenda, otherwise
      ;; a weird bug would invalidate the effect of org-agenda-tag-filter-preset
      ((tags "WORK/IN-PROG")
       (agenda "" ((org-agenda-span 'day)
                   (org-agenda-tag-filter-preset '("+WORK"))))))

     ("p" "Today's personal agenda"
      ((tags "PERSONAL/IN-PROG")
       (agenda "" ((org-agenda-span 1)
                   (org-agenda-tag-filter-preset '("+PERSONAL"))))))

     ("s" "Schedule view"
      ((tags "WORK/TODO"
             ((org-agenda-overriding-header "Work")
              (org-agenda-skip-function
               '(org-agenda-skip-entry-if 'scheduled 'deadline))))
       (tags "PERSONAL/TODO"
             ((org-agenda-overriding-header "Personal")
              (org-agenda-skip-function
               '(org-agenda-skip-entry-if 'scheduled 'deadline))))

       (tags "MENCTI/TODO"
             ((org-agenda-overriding-header "Mencti")
              (org-agenda-skip-function
               '(org-agenda-skip-entry-if 'scheduled 'deadline))))
       ))
     )))
#+END_SRC

*** Enable habit

#+BEGIN_SRC emacs-lisp
(use-package org
  :init
  (require 'org-habit)

  :custom
  (org-habit-graph-column 60)
  (org-habit-preceding-days 14)
  (org-habit-following-days 3))
#+END_SRC
*** Auto save

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  ;; save to the file directly, not to a temporary file
  (add-hook 'org-mode-hook 'auto-save-visited-mode)

  ; save but don't leave a message.
  (setq auto-save-no-message t)
  )
#+END_SRC

*** Mixed pitch

Show variable pitch for normal text, and monospace font for codes.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :commands (mixed-pitch-mode)
  ;; :hook
  ;; (org-mode . mixed-pitch-mode)
  ;; (git-commit-mode . mixed-pitch-mode)

  :custom
  ;; use the default box cursor instead of the I cursor
  (mixed-pitch-variable-pitch-cursor 'box)
  (mixed-pitch-set-height nil)

  :config
  ;; somehow the variable-pitch font needs to be reset in
  ;; mixed-pitch mode.
  (set-face-attribute 'variable-pitch nil :family shou/var-font)
  )
#+end_src

** Archiving

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-archive-location (concat (org-file-path "archive.org") "::* From %s"))
  :config
  ;; save archive automatically
  (advice-add 'org-archive-default-command :after #'org-save-all-org-buffers))
#+END_SRC


** Capturing
*** Use =org-clip-link= to insert title automatically

#+BEGIN_SRC emacs-lisp
(use-package org-cliplink
  :after org
  :commands (org-cliplink org-cliplink-capture)
  :bind ("C-c C-S-l" . org-cliplink))
#+END_SRC

*** Use =C-c c= for capturing

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind ("C-c c" . org-capture))
#+END_SRC

*** Capture templates

#+BEGIN_SRC emacs-lisp
(use-package org
  :init
  (defun shou/org-select-project ()
    "Prompt for a location to select a headline"
    (interactive)
    (let* ((all-headings (-map 'car (org-refile-get-targets "projects.org")))
           (filtered-headings (--remove (member it '("Chore")) all-headings))
           (choice (completing-read "Select project: " filtered-headings)))
      (s-concat "::" choice)))

  (defun shou/org-time-stamp-string ()
    (s-with (with-temp-buffer (org-time-stamp nil)) (s-chop-prefix "<") (s-chop-suffix ">")))

  :custom
  (org-capture-templates
   `(("w" "Work" entry (file+headline "projects.org" "Work")
      "* TODO %^{Task (Work)}\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("p" "Personal" entry (file+headline "projects.org" "Personal")
      "* TODO %^{Task (Personal)}\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("v" "Video (<15 min)" entry (file+headline "mencti.org" "Videos (Short)")
      "* TODO %(org-cliplink-capture) %^g\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("V" "Video (>15 min)" entry (file+headline "mencti.org" "Videos (Long)")
      "* TODO %(org-cliplink-capture) %^g\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("a" "Article" entry (file+headline "mencti.org" "Articles")
      "* TODO %(org-cliplink-capture) %^g\n:PROPERTIES:\n:Effort: %^{prompt|0:10|0:30|1:00|2:00}\n:Added: %U\n:END:\n\n\n%?"
      )
     ("c" "Literature" entry (file+headline "mencti.org" "Literature")
      "* TODO %^{Literature name}\n:PROPERTIES:\n:Added: %U\n:END:\n\n\n%?"
      )
     ("l" "Log" entry (file "inbox.org")
      "* %(shou/org-time-stamp-string)\n:PROPERTIES:\n:Added: %U\n:END:\n\n\n%?"
      :jump-to-captured t
      )

     ("d" "Day planning" plain (file+olp+datetree "plan.org")
      ,(concat ":PROPERTIES:\n:ADDED: %U\n:END:\n"
               "gunka:\n- [ ]%?\n- [ ]\n"
               "cilre:\n- [ ]\n- [ ]\n"
               "chore:\n- [ ] vocab\n- [ ] diary\n- [ ] email\n"
               "sevzi:\n- [ ]\n"
               )
      :time-prompt t
      :immediate-finish t
      :jump-to-captured t
      )

     ("n" "News" item (file+olp+datetree "nuzba.org")
      "%^{News item}"
      :immediate-finish t)

     ("L" "Org protocol link" entry (file+headline "mencti.org" "Captures")
      "* TODO %:description\n:PROPERTIES:\n:ADDED: %U\n:END:\nSCHEDULED: %t\n%:link\n"
      :immediate-finish t)
     )))
#+END_SRC

*** Refile

#+begin_src emacs-lisp
(use-package org
  :custom
  (org-refile-targets '(("projects.org" . (:maxlevel . 9))
                        ("mencti.org" . (:level . 1))
                        ))

  ;; refile in one go
  (org-outline-path-complete-in-steps nil)

  ;; show full path
  (org-refile-use-outline-path 'file)
  )
#+end_src

** Clocking
*** Clocking to "CLOCKING" drawer

I like clocking info to be in a separate drawer from "LOGBOOK" to avoid mixing with
 state change logs.

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-clock-into-drawer "CLOCKING"))
#+END_SRC

*** Resolving idle time and continuous clocking

If I've been idle for 15 minutes while clocking, notify me what to do with
the clock.

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-clock-idle-time 15))
#+END_SRC

*** Switch task's TODO status when clocking in/out

This section configures the following mechanisms:

- when clock in, automatically change TODO to IN-PROG (1)
- when changing TODO to IN-PROG, automatically clock in (2)
- when changing IN-PROG to DONE, automatically clock out (3)

[[http://doc.norang.ca/org-mode.html#sec-9-1][Org Mode - Organize Your Life In Plain Text!]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  ;; (1)
  ; (org-clock-in-switch-to-state 'shou/clock-in-to-in-prog)
  ;; (3)
  (org-clock-out-when-done t)

  :config
  (defun shou/auto-clock-in ()
    "Automatically clock in if current task is changing to IN-PROG state"
    (when (member org-state '("IN-PROG"))
      (org-clock-in)
      (message "State changed to IN-PROG, automatically clocking in")))

  (defun shou/clock-in-to-in-prog (_)
    "Switch a task from TODO to IN-PROG when clocking in"
    (when (member (org-get-todo-state) '("TODO")) "IN-PROG"))
  ;; (2)
  (add-hook 'org-after-todo-state-change-hook 'shou/auto-clock-in))
#+END_SRC


*** Resume clocking on Emacs restart

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-clock-persist t)
  :config
  (org-clock-persistence-insinuate))
#+END_SRC

*** Include current clocking task in reports

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-clock-report-include-clocking-task t))
#+END_SRC

*** Delete clock time of zero duration

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-clock-out-remove-zero-time-clocks t))
#+END_SRC

*** Secretaria: Clocking task Reminder

#+begin_src emacs-lisp
(use-package secretaria
  :defer t
  :custom
  ;; remind me about every 10 minutes
  (secretaria-clocked-in-reminder-every-minutes 10)
  (secretaria-today-unknown-time-appt-remind-every 10)
  )
#+end_src

*** Pomodoro timer

#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :after org
  ; :init
  ; (evil-define-key 'motion org-agenda-mode-map (kbd "P") 'org-pomodoro)
  :bind
  (("C-c C-x C-p" . org-pomodoro)
   :map org-mode-map
   ("C-c C-x C-p" . org-pomodoro))
  :custom
  (org-pomodoro-format "Pomo %s")
  (org-pomodoro-short-break-format "Break %s")
  (org-pomodoro-long-break-format "Long break %s")
  (org-pomodoro-start-sound-p t)
  (org-pomodoro-ticking-sound-p t)
  (org-pomodoro-ticking-sound-states '(:pomodoro))
  (org-pomodoro-ticking-frequency 1)
  :config
  ;; automatically start next pomo after a break
  (add-hook 'org-pomodoro-break-finished-hook (lambda () (interactive) (org-pomodoro '(16)))))
#+END_SRC

*** org-mru-clock

#+BEGIN_SRC emacs-lisp
(use-package org-mru-clock
  :bind (("C-c C-x C-j" . org-clock-goto)
         ("C-c C-x C-o" . org-clock-out)
         ("C-c C-x C-i" . org-clock-in)
         ("C-c C-x C-k" . org-mru-clock-in)
         ("C-c C-x C-x" . org-clock-in-last))
  :custom
  (org-mru-clock-how-many 100)
  (org-mru-clock-keep-formatting t)
  (org-mru-clock-predicate nil))

#+END_SRC

*** Show clock in frame title

Ref: [[https://lists.gnu.org/archive/html/emacs-orgmode/2012-02/msg00854.html][Re: {O} Clocking time in frame title bar]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-clock-clocked-in-display 'both))
#+END_SRC


*** Mark clocking task as done
:PROPERTIES:
:ID:       EEA9B2F1-4CE8-4D24-A0CB-4758E2CAF724
:END:

#+BEGIN_SRC emacs-lisp
(defvar shou/previously-clocking '())

(defun shou/temporarily-clock-out ()
  (interactive)
  (save-window-excursion
    (if (org-clocking-p)
        (progn
          (org-clock-goto)
          (add-to-list 'shou/previously-clocking
                       (cons org-clock-heading (org-id-get-create)))
          (org-clock-out))
      (message "No clock is active now.")
      )))

(defun shou/mark-clocking-task-as-todo-and-clock-out ()
  (interactive)
  (save-window-excursion
    (if (org-clocking-p)
        (progn
          (org-clock-goto)
          (add-to-list 'shou/previously-clocking
                       (cons org-clock-heading (org-id-get-create)))
          (org-todo 'todo)
          (org-clock-out)
          (save-buffer))
      (message "No clock is active now."))))

(defun shou/resume-previous-clock (id)
  (interactive)
  (save-window-excursion
    (org-id-goto id)
    (org-clock-in)
    (shou/remove-previous-clock id)))

(defun shou/remove-previous-clock (id)
  (when (not (null id))
    (setq shou/previously-clocking
          (--remove (s-equals? id (cdr it)) shou/previously-clocking))))

(defun shou/mark-clocking-task-as-done ()
  "Find current clocking task and mark it as done."
  (interactive)
  (save-window-excursion
    (if (org-clocking-p)
        (progn
          (org-clock-goto)
          (org-todo 'done)
          (shou/remove-previous-clock (org-id-get))
          (save-buffer))
      (message "No clock is active now."))))

(bind-key "C-c C-x C-d" 'shou/mark-clocking-task-as-done)
(bind-key "C-c C-x C-d" 'shou/mark-clocking-task-as-done org-mode-map)
#+END_SRC

** Presentation

Hotkeys:

- =f5=:: edit
- =j=/=k=:: scroll
- =c=/=C=:: jump between src blocks
- =e=:: edit src block

#+BEGIN_SRC emacs-lisp
(use-package epresent
  :after org
  :commands epresent-run
  :custom
  (epresent-text-scale 1.0)
  (epresent-pretty-entities t)
  (epresent-hide-emphasis-markers t)
  )
#+END_SRC

Make plain lists folded by default:

#+begin_src emacs-lisp
(setq org-cycle-include-plain-lists 'integrate)
#+end_src

** Inline Image
*** Set inline image width to 600px

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom (org-image-actual-width nil))
#+END_SRC

*** Enable drag-n-drop download for images

#+BEGIN_SRC emacs-lisp
(use-package org-download
  :after org
  :commands (org-download-image org-download-enable org-download-screenshot)
  :hook (dired-mode . org-download-enable)
  )

#+END_SRC

** Annotating documents

#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :after org
  :commands org-noter)
#+END_SRC

** Exporting


#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox
  ;; code highlight in html export
  (use-package htmlize)

  ;; gfm, mediawiki, etc
  (use-package ox-pandoc
    :custom
    (org-pandoc-menu-entry
     '(
       (?w "as mediawiki." org-pandoc-export-as-mediawiki)
       (?g "as gfm." org-pandoc-export-as-gfm)
       ))
    (org-pandoc-options-for-mediawiki '((shift-heading-level-by . "1")))
    (org-pandoc-options-for-gfm '((shift-heading-level-by . "1")
                                  (wrap . "none")
                                  )))

  (setq org-export-with-broken-links 'mark)

  ;; latex options
  (setq org-export-with-smart-quotes t)
  (setq org-latex-pdf-process
   '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (setq org-latex-compiler "xelatex")
  (setq TeX-engine 'xetex)
  (setq TeX-PDF-mode t)

  ;; slides
  ;; (use-package ox-beamer)
)
#+END_SRC


** Custom keystrokes
*** In CLI rebind "<tab>"
*** =C-c n= to quickly open org files

#+BEGIN_SRC emacs-lisp
(defun open-org-file ()
  "Prompt the user to open a org file in the org file directory"
  (interactive)
  (let* ((dir (org-file-path "."))
         (files (f--files dir (f-ext? it "org")))
         (relative-files (--map (f-relative it dir) files))
         (chosen-file (completing-read "Select file: " relative-files)))
    (find-file (f-expand chosen-file dir))))

(bind-key "C-c n" 'open-org-file)
#+END_SRC

*** Use =C-c l= and =C-c L= to collect links

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind
  ("C-c l" . org-store-link)
  ("C-c L" . shou/copy-idlink-to-clipboard)

  :config
  ;; Adapted from Rainer's blog:
  ;; https://koenig-haunstetten.de/2018/02/17/improving-my-orgmode-workflow/
  (defun shou/copy-idlink-to-clipboard()
    "Copy an ID link with the
headline to killring, if no ID is there then create a new unique
ID.  This function works only in org-mode or org-agenda buffers.

The purpose of this function is to easily construct id:-links to
org-mode items. If its assigned to a key it saves you marking the
text and copying to the killring."
    (interactive)
    (save-window-excursion
      (when (eq major-mode 'org-agenda-mode) ;switch to orgmode
        (org-agenda-show)
        (org-agenda-goto))
      (when (eq major-mode 'org-mode) ; do this only in org-mode buffers
        (let* ((head (nth 4 (org-heading-components)))
               ;; replace links with their description
               (clean-head (replace-regexp-in-string org-link-bracket-re "\\2" head))
               (id (funcall 'org-id-get-create))
               (link (format "[[id:%s][%s]]" id clean-head)))
          (kill-new link)
          (message "Copied %s to killring (clipboard)" link)
        )))))
#+END_SRC

*** Use =C-c C-c= to save and quit =org-src-mode=

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (:map org-src-mode-map ("C-c C-c" . org-edit-src-exit)))
#+END_SRC

*** Quickly insert timestamp anywhere

#+begin_src emacs-lisp
(use-package org
  :bind (:map org-mode-map ("<f5>" . shou/insert-timestamp))
  :config
  (defun shou/insert-timestamp ()
    (interactive)
    (insert (org-format-time-string "[%H:%M]: " (org-current-time)))))
#+end_src

*** Disable unused export options

#+BEGIN_SRC emacs-lisp
(use-package org
  :init
  (setq org-export-backends '(ascii html latex)))
#+END_SRC

** Calendar integration

#+BEGIN_SRC emacs-lisp
(use-package org-caldav
  :defer t
  :custom
  (org-caldav-url
   (concat "https://caldav.fastmail.com/dav/calendars/user/"
           priv/fastmail-caldav-user))
  (org-caldav-calendar-id priv/fastmail-caldav-calendar-id)
  (org-caldav-inbox (org-file-path "time-blocking.org"))
  (org-caldav-files (list (org-file-path "time-blocking.org")))
  (org-caldav-sync-direction 'cal->org)
  (org-icalendar-timezone "Asia/Shanghai")
)
#+END_SRC

** Customize source languages

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-src-lang-modes
   '(("ocaml" . tuareg)
     ("elisp" . emacs-lisp)
     ("ditaa" . artist)
     ("asymptote" . asy)
     ("dot" . fundamental)
     ("sqlite" . sql)
     ("calc" . fundamental)
     ("C" . c)
     ("cpp" . c++)
     ("C++" . c++)
     ("screen" . shell-script)
     ("shell" . sh)
     ("bash" . sh)
     ("lojban" . lojban)
   )))
#+END_SRC


** Org babel

#+begin_src emacs-lisp
(use-package ob-restclient
  :defer t)

(use-package org
  :custom
  (org-babel-load-languages '((ditaa . t)
                              (gnuplot .t)
                              (python . t)
                              (haskell . t)
                              (scheme . t)
                              (js . t)
                              (restclient . t)
                              (shell . t)
                              ))

  (python-shell-completion-native-enable nil)

  (haskell-process-type 'stack-ghci)
  (haskell-program-name "ghci")

  :config
  (use-package gnuplot :commands gnuplot-mode)
  )
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24810 63568 883307 0) :init (24810 63568 883297 0) :config (24810 63568 883292 0) :config-secs (0 0 1414 0) :init-secs (0 0 1451 0) :use-package-secs (0 0 14557 0)))

** Automatic backup

I automatically backup my org files using git after idle for a while. The mode is activated for specific folder only using =.dir-locals.el=.

#+begin_src emacs-lisp
(use-package git-auto-commit-mode
  :commands git-auto-commit-mode
  :custom
  ;; auto push to remote
  (gac-automatically-push-p t)
  ;; only backup after 120 secs
  (gac-debounce-interval 120)
  ;; do not prompt for gpg signature
  (gac-commit-additional-flag "--no-gpg-sign"))
#+end_src

** Open file with apps

#+begin_src emacs-lisp
(setf
 (alist-get "\\.pdf\\'" org-file-apps) "evince %s"
 )
#+end_src

** Org latex

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (cond
   ((executable-find "dvisvgm")
    ;; use svg to avoid blurring or scaling
    (setq org-preview-latex-default-process 'dvisvgm)
    (setf (plist-get org-format-latex-options :scale) 1.5))

   (t
    (setf (plist-get org-format-latex-options :scale) 3.0))))

(use-package org-fragtog
  :commands org-fragtog-mode)
#+end_src

** Org modern


#+begin_src emacs-lisp
(use-package org-modern
  :after org
  :config
  (global-org-modern-mode)

  ;; do not put label to the right
  (setq org-tags-column 0)

  ;; do not align agenda tags to the right
  (setq org-agenda-tags-column 0
        org-agenda-block-separator ?─)

  ;; label should have the same size as normal text
  ;; as not to screw up table alignment.
  (set-face-attribute 'org-modern-label nil
                      :inherit 'fixed-pitch
                      :height 'unspecified)

  ;; the original level-2 star doesn't look good in my font.
  (setq org-modern-star '("◉" "⃝" "◈" "◇" "✳"))
  )
#+end_src

* Email

** Email reader

#+begin_src emacs-lisp
(use-package mu4e
  ;; only use system package. do not install from melpa
  :if (and (executable-find "mu")
           (executable-find "offlineimap"))
  :init
  ;; add mu4e directory to load-path
  (let* ((mu4e-src-dirs (f-glob "/usr/share/emacs/site-lisp/elpa-src/mu4e-*"))
         (mu4e-src-dir (and mu4e-src-dirs (car mu4e-src-dirs))))
    (when mu4e-src-dir
      (add-to-list 'load-path mu4e-src-dir)))

  :straight nil
  :ensure nil
  :commands mu4e
  :custom
  ;; update and reindex email
  (mu4e-get-mail-command "offlineimap -o -q")
  ;; update every 10 minutes
  (mu4e-update-interval (* 60 10))
  ;; do not spam "Retrieving mail..." in my minibuffer
  (mu4e-hide-index-messages t)
  ;; do not keep message buffer
  (message-kill-buffer-on-exit t)
  ;; ask every time when context is not clear
  (mu4e-context-policy 'pick-first)
  ;; use vertico instead of ido
  (mu4e-completing-read-function #'completing-read)

  :init
  ;; start mu4e in background after 5 seconds of idle
  (run-with-idle-timer 5 nil (lambda () (mu4e t)))

  :config
  (require 'mu4e-icalendar)
  (mu4e-icalendar-setup)
  )
#+end_src

** Mark as spam

#+begin_src emacs-lisp
  (with-eval-after-load 'mu4e
    (defvar mu4e-spam-folder)

    (add-to-list 'mu4e-marks
                 '(spam
                   :char       "P"
                   :prompt     "spam"
                   :show-target (lambda (target) mu4e-spam-folder)
                   :action      (lambda (docid msg target)
                                  (mu4e--server-move docid mu4e-spam-folder "+S-u-N"))))

    (mu4e~headers-defun-mark-for spam)
    (define-key mu4e-headers-mode-map (kbd "P") 'mu4e-headers-mark-for-spam))
#+end_src

** Send email

#+begin_src emacs-lisp
(use-package smtpmail
  :after mu4e
  :ensure nil
  :custom
  (smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil)))
  (smtpmail-auth-credentials
   '(("smtp.gmail.com" 587 user-email-address nil)))
  (smtpmail-default-smtp-server "smtp.gmail.com")
  (smtpmail-smtp-server "smtp.gmail.com")
  (smtpmail-smtp-service 587)

  :config
  (setq message-send-mail-function 'smtpmail-send-it)
  )
#+end_src

** Email alerts

#+begin_src emacs-lisp
(use-package mu4e-alert
  :after mu4e
  :straight (:host github :repo "xzz53/mu4e-alert")
  :custom
  (mu4e-alert-interesting-mail-query
   "flag:unread maildir:/tubi/INBOX")
  (mu4e-alert-set-default-style 'libnotify)

  :config
  (mu4e-alert-enable-notifications)
  (mu4e-alert-enable-mode-line-display)
  )
#+end_src

* Debugging cheatsheet

** Trace function argument/return value

#+begin_src emacs-lisp :tangle no
(trace-function 'dap-tooltip-mode)
#+end_src

** Show call stack when a function gets called

#+begin_src emacs-lisp :tangle no
(debug-on-entry 'dap-tooltip-mode)
#+end_src

** Show recent interactions

Useful for finding out what gets triggered in a recent user action.

Type =C-h l= or =M-x view-lossage=.

** Enable debug on error

#+begin_src emacs-lisp :tangle no
(toggle-debug-on-error)
#+end_src

** Invalidate org-babel cache (preferences.el)

Just =C-x C-e= on the following line.

#+begin_src emacs-lisp :tangle no
(delete-file "~/.emacs.d/preferences.el")
#+end_src

* Playground

Try out stuff here and execute manually.

#+begin_src emacs-lisp :tangle no
(+ 1 1)

(defun scroll-up-benchmark ()
  (interactive)
  (end-of-buffer)
  (redisplay)
  (let ((oldgc gcs-done)
        (oldtime (float-time)))
    (condition-case nil (while t (previous-line) (redisplay))
      (error (message "GCs: %d Elapsed time: %f seconds"
                      (- gcs-done oldgc) (- (float-time) oldtime))))))

(defun scroll-up-profile ()
  (interactive)
  (end-of-buffer)
  (redisplay)
  (when (fboundp 'profiler-stop)
    (profiler-stop))
  (profiler-start 'cpu)
  (let ((oldgc gcs-done)
        (oldtime (float-time)))
    (condition-case nil (while t (previous-line) (redisplay))
      (error (message "GCs: %d Elapsed time: %f seconds"
                        (- gcs-done oldgc) (- (float-time) oldtime))))
    (profiler-report)
    (profiler-stop)))
#+end_src


#+RESULTS:
: 2

* fanmo

.i fanmo
