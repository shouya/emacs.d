#+TITLE: My Emacs Preferences
#+latex_compiler: xelatex
#+latex_header: \usemintedstyle{emacs}

* Boot up
** Enable packages are loadable

=lisp/= stores modules I copied from [[https://github.com/purcell/emacs.d][purcell/emacs.d]].

#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+end_src

=site-lisp/= stores downloaded modules that are not on MELPA.

#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
#+end_src

** Start server automatically

#+begin_src emacs-lisp
(use-package server
  :demand t
  :config
  (defun shou/server-start ()
    (when (not (server-running-p))
      (server-start)))
  (add-hook 'after-init-hook 'shou/server-start))
#+end_src

** Start edit server (for browser extensions)

Browser extension: [[https://github.com/GhostText/GhostText][GhostText]]

#+begin_src emacs-lisp
(use-package atomic-chrome
  :ensure t
  :hook (emacs-startup . atomic-chrome-start-server)
  :if (display-graphic-p)
  :custom
  (atomic-chrome-url-major-mode-alist
   '(("wiki\\.lain\\.li" . mediawiki-mode)
     ("github\\.com" . gfm-mode))))
#+end_src

** Make window resizable by window manager

#+begin_src emacs-lisp
(setq-default frame-resize-pixelwise t)
#+end_src

** Load some basic libraries and packages

#+begin_src emacs-lisp
(use-package dash :ensure t :demand t)
(use-package f :ensure t :demand t)
(use-package s :ensure t :demand t)
;; magit/forge requires the latest version of transient instead of the built-in one.
(use-package transient :ensure (:fetcher github :repo "magit/transient"))

(elpaca-wait)
#+end_src

* Basic behavior

These are things that I expect to work all right even when the config contains error later at some point.

The goal in this section is to cover the most critical editing features I need to effectively edit emacs config.

** Hotkey to edit config

** =C-c e= to edit current preferences

#+begin_src emacs-lisp
(defun shou/find-emacs-config nil
  (interactive)
  (find-file (expand-file-name "preferences.org" user-emacs-directory)))
(bind-key "C-c e" 'shou/find-emacs-config)
#+end_src

** Always ask for short answers

"yes/no" -> "y/n"

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)

;; Emacs 29
(when (boundp 'use-short-answers)
  (setq use-short-answers t))
#+end_src

** Save customization in separate file

By default the customization is saved into =init.el=. Avoid the mess by saving it
in a separate file =custom.el=.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
(load-file custom-file)
#+END_SRC

** Recursive minibuffer

Allow performing actions in minibuffer that uses minibuffer.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

** Window manipulation and navigation keys

#+begin_src emacs-lisp
(bind-key "C-x |" #'split-window-right)
(bind-key "C-x -" #'split-window-below)

(defun shou/other-window-or-ace ()
  "Switch to other window. If C-u is pressed, call ave-window."
  (interactive)
  (if (not (equal '(4) current-prefix-arg))
      (other-window 1)
    ;; show window keys in the mode line
    (funcall 'ace-window-display-mode 1)
    (call-interactively 'ace-window)
    (funcall 'ace-window-display-mode -1)))
(bind-key "M-o" #'shou/other-window-or-ace)

(defun shou/other-window-backwards nil (interactive) (other-window -1))
(bind-key "M-O" #'shou/other-window-backwards)

;; prefer splitting window vertically (|)
(setq split-width-threshold 140)
(setq split-height-threshold nil)

;; window layout undo/redo with C-c left/right
(winner-mode 1)
#+end_src

*** Ace window

#+begin_src emacs-lisp
(use-package ace-window
  :ensure t
  :commands (ace-window-display-mode ace-window)
  :custom
  ;; always dispatch window
  (aw-dispatch-always t)
  ;; use home row keys for window switching
  (aw-keys '(?a ?s ?d ?f ?j ?k ?l))
  ;; do not show an overlay for window switching character
  (aw-display-mode-overlay nil)
  ;; custom dispatch keys
  (aw-dispatch-alist
   '((?x aw-delete-window "Delete window")
     (?m aw-swap-window "Swap window")
     (?| aw-split-window-vert "Ace - Split vertically")
     (?- aw-split-window-horz "Ace - Split horizontally")
     (?0 delete-other-windows "Ace - Maximize window")
     (?b balance-windows "Balance window")
     (?+ balance-windows)
     (?u (lambda (&rest _) (winner-undo)) "Winner - Undo")
     (?r (lambda (&rest _) (winner-redo)) "Winner - Redo")
     (?? aw-show-dispatch-help)
     )))
#+end_src

** Kill current buffer by default

Bound to =C-x k=.

#+begin_src emacs-lisp
(defun shou/kill-current-buffer nil
  (interactive)
  (kill-buffer (current-buffer)))
(bind-key [remap kill-buffer] 'shou/kill-current-buffer)
#+end_src

** Basic editing
*** Join line

The default join line hotkey =C-j= join the current line with the previous line. Whereas I prefer to join current line with next line.

#+begin_src emacs-lisp
(defun shou/join-line () (interactive) (save-excursion (next-line) (delete-indentation)))

;; C-j
(bind-key* [remap join-line] 'shou/join-line)
(bind-key* "C-j" 'shou/join-line)
#+end_src
*** Transpose char

Likewise, I would like to transpose the current char with the next instead with the previous one.

#+begin_src emacs-lisp
(defun shou/transpose-next-char ()
  (interactive)
  (save-excursion
    (forward-char)
    (transpose-chars 1)))

;; C-t
(bind-key [remap transpose-chars] 'shou/transpose-next-char)
#+end_src

*** Newline

Ensure the final newline in a text file.

#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src

*** Delete selection mode

Delete current active region when I begin typing or pasting.

#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src

*** Mark region

#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)
         ("C--" . er/contract-region))
  :custom
  (expand-region-subword-enabled t))
#+end_src

*** Disable bi-directional text support

Myth says that turning off bi-directional text support can improve performance. I don't use bi-directional text anyway.

#+begin_src emacs-lisp
(setq bidi-inhibit-bpa t)
#+end_src

*** Disable unused mouse buttons

By default, right mouse button is bound to set mark and middle mouse button is bound to paste. Those buttons are more often mistakenly pressed and messes up the buffer.

#+begin_src emacs-lisp
(global-unset-key [mouse-3])
(global-unset-key [mouse-2])
(global-unset-key (kbd "C-<mouse-1>"))
(global-unset-key (kbd "C-<mouse-2>"))
(global-unset-key (kbd "C-<mouse-3>"))
#+end_src

*** Disable tab indentation

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

** Save last position for each file

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook (lambda () (save-place-mode 1)))
#+end_src

** Save recent file

Built-in module:

#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :bind ("C-x f" . shou/find-recent-file)
  :config
  (add-to-list 'recentf-exclude (rx "bookmarks" eol))
  ;; save 200 files instead of default 20 files in history
  (setq recentf-max-saved-items 200)
  (recentf-mode 1)
  (defun shou/find-recent-file ()
    (interactive)
    (find-file (completing-read "Choose recent file: " recentf-list))
    )
  (with-eval-after-load 'marginalia
    (add-to-list 'marginalia-prompt-categories '("Choose recent file:" . file)))
  )
#+end_src

** Backup file

Store backup files to an independent directory instead of the same directory as the original file.

#+begin_src emacs-lisp
(let* ((base-dir (cond
                  ((f-directory? "~/.cache") "~/.cache")
                  (t "/tmp")))
       (backup-dir (f-join base-dir "emacs-backup")))
  (when (not (f-directory? backup-dir))(f-mkdir backup-dir))
  (setq backup-directory-alist `((".*" . ,backup-dir))
        auto-save-file-name-transforms `((".*" ,backup-dir t))))
#+end_src

** Bookmarks

I keep some frequently accessed files in emacs bookmark so I can quickly jump to them via C-x r b.

Key bindings:

- =C-x r m= (bookmark-set): add bookmark
- =C-x r b= (bookmark-jump): jump to a bookmark, select interactively
- =C-x r l= (list-bookmarks): list bookmarks for inspection (and deletion)

#+begin_src emacs-lisp
(use-package bookmark
  :config
  ;; save bookmark whenever a bookmark is set
  (setq bookmark-save-flag 1)
  )
#+end_src

** Basic org mode behavior

#+begin_src emacs-lisp
(use-package org
  :config
  ;; enable quick input for blocks like "<s"
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (require 'org-tempo)

  ;; do not automatically ident based on heading
  (setq org-adapt-indentation nil)

  ;; indent contents according to the heading level
  (add-hook 'org-mode-hook #'org-indent-mode)

  ;; save to the file directly, no a temp file
  (add-hook 'org-mode-hook 'auto-save-visited-mode)
  ;; save and don't leave a message.
  (setq auto-save-no-message t)

  ;; do not add extra indentation to source blocks
  (setq org-src-preserve-indentation t)

  ;; use a single unicode character for folded
  (setq org-ellipsis "…")

  ;; additional key binding for quiting org source code edit (orig: C-c ')
  (bind-key "C-c C-c" #'org-edit-src-exit 'org-src-mode-map)

  ;; hide the "=", "*", "/" symbols
  (setq org-hide-emphasis-markers t)

  ;; do not put label to the right
  (setq org-tags-column 0)

  ;; put footnote under the current heading instead of a "footnotes" section
  (setq org-footnote-section nil)

  ;; Avoid accidental text edit in invisible area
  (setq org-catch-invisible-edits 'show-and-error)

  ;; make TAB acts as in major mode
  (setq org-src-tab-acts-natively t)

  ;; use alternating set of bullet for lists. Default behaviour is to
  ;; only use "-".
  (setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+")))
  )
#+end_src

** Hide UI elements

#+begin_src emacs-lisp
(defun shou/hide-ui-elements ()
  (when (boundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (boundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (boundp 'scroll-bar-mode) (scroll-bar-mode -1)))
(shou/hide-ui-elements)
#+end_src

Also, do not show splash screen.

#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
#+end_src

** Better help

#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :bind
  ("C-h k" . helpful-key)
  ("C-h f" . helpful-callable)
  ("C-h v" . helpful-variable)

  :config
  (add-hook 'helpful-mode-hook #'shou/set-tab-width-to-8)
  (defun shou/set-tab-width-to-8 nil (setq-local tab-width 8))
  )
#+end_src

** Save history across restarts

#+begin_src emacs-lisp
(use-package savehist
  :demand t
  :config
  (savehist-mode 1))
#+end_src

** Sandbox mode

#+begin_src emacs-lisp
(defun shou/enable-sandbox ()
  (setq make-backup-files nil)
  (setq auto-save-default nil)
  (setq transient-save-history nil)
  (setq org-clock-persist nil)
  (setq projectile-auto-update-cache nil)
  (setq save-place-file "/tmp/emacs-sandbox/save-place")
  (setq savehist-file "/tmp/emacs-sandbox/history")
  (add-to-list 'native-comp-eln-load-path "/tmp/emacs-sandbox/eln-cache")

  (savehist-mode -1)
  )
#+end_src

** Set default major mode

The default major mode is fundamental-mode, which is very limited.

#+begin_src emacs-lisp
(setq initial-major-mode 'text-mode)
#+end_src

** Set default input method

#+begin_src emacs-lisp
(setq default-input-method "TeX")
#+end_src

* UI

** Tweak main UI

Show a simpler title.

#+begin_src emacs-lisp
(setq frame-title-format '("%b - %m @ Emacs"))
#+end_src

Never show graphical dialog box.

#+begin_src emacs-lisp
(setq use-dialog-box nil)
#+end_src

** Color theme

#+begin_src emacs-lisp
;; make src block stand out
(setq modus-themes-org-blocks 'gray-background)
;; allow italic constructs such as comments and helper messages
(setq modus-themes-italic-constructs t)

(load-theme 'modus-operandi t nil)
(add-hook 'emacs-startup-hook
	  (lambda () (enable-theme 'modus-operandi)))
#+end_src

** Fonts

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
	  (lambda ()
            (set-frame-font "JetBrains Mono ExtraLight")
            (set-face-attribute 'default nil :family "JetBrains Mono ExtraLight" :height 130)))
#+end_src

** Fonts for special codepoints

The default monospace font I use doesn't have much coverage for extensive codepoints. To avoid fallback to the system's default behavior, I need to specify the fonts to use for these codepoints.

First, non-latin script should be displayed with the correct font variants:

#+begin_src emacs-lisp
(cl-loop for (script . font) in
         '((han . "Noto Sans CJK TC DemiLight")
           (kana . "Noto Sans CJK JP DemiLight")
           (hangul . "Noto Sans CJK KR DemiLight")
           (phonetic . "Noto Sans")
           (greek . "Noto Sans Light")
           )
         do
         (set-fontset-font t ;; font for 'default face
                           script
                           (font-spec :family font)))
#+end_src

Second, we set the font set for various types of special symbols:

#+begin_src emacs-lisp
;; IPA symbols and diacritic marks (https://www.compart.com/en/unicode/block/U+0250)
(set-fontset-font t '(#x0250 . #x036F) (font-spec :family "DejaVu Sans Mono"))

;; gemoetric shapes (https://www.compart.com/en/unicode/block/U+25A0)
(set-fontset-font t '(#x25A0 . #x25FF)
                  (font-spec :family "Noto Sans Mono"))

;; general punctuation (https://www.compart.com/en/unicode/block/U+2000)
;; to ensure a uniform look for punctuations (especially bullets like ◦•‣)
(set-fontset-font t '(#x2000 . #x206F)
                  (font-spec :family "Noto Sans Mono"))

;; symbols cannot be overriden by fontset by default. Turning off this setting.
(setq use-default-font-for-symbols nil)
#+end_src

** Icon fonts

In order for the icons to work it is very important that you install
the Resource Fonts included in this package, they are available in the
fonts directory. You can also install the latest fonts for this
package in the (guessed?) based on the OS by calling the following
command:

=M-x all-the-icons-install-fonts=

#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :commands all-the-icons-install-fonts)
#+end_src

** Modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :hook (emacs-startup . doom-modeline-mode)
  :custom
  (doom-modeline-height 30)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-env-version nil)
  (doom-modeline-lsp t)
  (doom-modeline-modal-icon nil)
  (doom-modeline-buffer-state-icon t)
  (doom-modeline-project-detection 'projectile)
  (doom-modeline-persp-name nil)
  (doom-modeline-mu4e nil)
  ;; do not use project relative path
  (doom-modeline-buffer-file-name-style 'buffer-name)

  :config
  (doom-modeline-mode 1)
  (set-face-attribute 'mode-line nil :height 130)
  (set-face-attribute 'mode-line-inactive nil :height 130))
#+end_src

** Highlight uncommitted changes

#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :hook (emacs-startup . global-diff-hl-mode))
#+end_src

** Show matching parenthesis

The default setting highlights only the parenthesis. =mix= makes it
highlight the entired expression enclosed by the parenthesis if the
other parenthesis is beyond visible area.

#+begin_src emacs-lisp
(setq show-paren-style 'mixed)
#+end_src

** Automatic window resizing

#+begin_src emacs-lisp
(use-package golden-ratio
  :ensure (:host github :repo "shouya/golden-ratio.el")
  :disabled t
  :hook (emacs-startup . golden-ratio-mode)
  :custom
  (golden-ratio-exclude-buffer-names '("*Ediff Control Panel*"))
  (golden-ratio-exclude-buffer-regexp '("^\\*dape-"))
  (golden-ratio-exclude-modes '(treemacs-mode ediff-mode))
  :config
  ;; Instead of each window occupies 0.618 of the screen, makes it
  ;; occupy half of the screen. This prevents unnecessary resizing
  ;; when two side-by-side windows are open.
  (setq golden-ratio--value 2.0)

  ;; avoid resizing which-key buffer
  (with-eval-after-load 'which-key
    (add-to-list 'golden-ratio-inhibit-functions
                 (lambda ()
                   (and which-key--buffer
                        (window-live-p (get-buffer-window which-key--buffer))))))
  )
#+end_src

** Transpose window layout

#+begin_src emacs-lisp
(use-package transpose-frame
  :ensure t
  :init
  ;; window-redisplay-end-trigger was obsolete and removed from latest
  ;; emacs 29 snapshot.
  ;;
  ;; I fset these functions to ignore so transpose-frame doesn't break.
  (when (not (fboundp 'window-redisplay-end-trigger))
    (fset 'window-redisplay-end-trigger 'ignore)
    (fset 'set-window-redisplay-end-trigger 'ignore))

  :commands (transpose-frame flip-frame)
  :bind ("C-x C-t" . transpose-frame)
  )
#+end_src

** Popup window

Show popup window in desired styles.

#+begin_src emacs-lisp
(use-package popwin
  :ensure t
  :hook (emacs-startup . popwin-mode)
  :config
  (push '("*elixir-format-errors*" :noselect t) popwin:special-display-config)
  (push "*idris-repl*" popwin:special-display-config)
  (push '("*idris-holes*" :noselect t) popwin:special-display-config)
  (push '("*Help*" :stick t) popwin:special-display-config)
  (push "*Warnings*" popwin:special-display-config)
  (push "*rustfmt*" popwin:special-display-config)
  (push "*explain-pause-log*" popwin:special-display-config)
  (push "*explain-pause-profiles*" popwin:special-display-config)
  (push '("*Flycheck errors*" :position bottom :stick t) popwin:special-display-config)
  (push '(cargo-process-mode :position bottom :stick t :height 10) popwin:special-display-config)
)
#+end_src

** Show page break line (=^L=)

#+begin_src emacs-lisp
(use-package page-break-lines
  :ensure t
  :hook (emacs-startup . global-page-break-lines-mode))
#+end_src

** Line wrap

Enable line wrap by default:

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'visual-line-mode)
#+end_src

* Editing
** Behavior tweaks
*** Remove trailing whitespace on save

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Scroll other window with M-up/down

Stolen from https://stackoverflow.com/a/45363946/1232832.

#+begin_src emacs-lisp
(bind-key "M-<up>" 'scroll-other-window)
(bind-key "M-<down>" 'scroll-other-window-down)
#+end_src

*** Show column number

#+begin_src emacs-lisp
(column-number-mode 1)
#+end_src

** Minibuffer completion

Show vertical completion for minibuffer options:

#+begin_src emacs-lisp
(use-package vertico
  :ensure (:host github
		 :repo "minad/vertico"
		 :files (:defaults "extensions/*")
		 :includes (vertico-repeat))
  :hook
  (emacs-startup . vertico-mode)

  :custom
  (vertico-cycle t)
  )
#+end_src

And show rich info on the margin:

#+begin_src emacs-lisp
(use-package marginalia
  :ensure t
  :init
  (marginalia-mode)

  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle))

  :config
  (setq marginalia-command-categories
        (append '((projectile-find-file . file)
                  (projectile-find-dir . file)
                  (projectile-switch-project . file))
                marginalia-command-categories))
  )
#+end_src

Narrow down the selection using orderless style:

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides
   '(
     ;; TRAMP hostname completion requires "basic" style to work
     (file (styles basic partial-completion)))
   )
  ;; ignore case for filenames
  (read-file-name-completion-ignore-case t)
  )
#+end_src

** Completion

#+begin_src emacs-lisp
(use-package corfu
  :ensure (corfu :files (:defaults "extensions/*")
                 :includes (corfu-echo
                            corfu-info
                            corfu-directory
                            corfu-history
                            corfu-popupinfo))

  :bind
  (:map corfu-map
        ("C-SPC" . corfu-insert-separator))

  :hook
  (emacs-startup . global-corfu-mode)
  (emacs-startup . corfu-popupinfo-mode)

  :custom
  ;; if the line is already indented, try complete instead
  (tab-always-indent 'complete)

  ;; enable auto completion
  (corfu-auto t)

  :config
  ;; enable corfu completion for eval-expession/shell-command
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)

  ;; used by copilot.el to accept completion
  (unbind-key "<remap> <move-end-of-line>" 'corfu-map)
  )
#+end_src

Show icon for completion:

#+begin_src emacs-lisp
(use-package kind-icon
  :after corfu
  :ensure t
  :functions (kind-icon-margin-formatter)
  :init
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
  :custom
  (kind-icon-default-face 'corfu-default)
  (kind-icon-default-style
   '(:padding -1.1 :stroke 0 :margin 0 :radius 0 :height 0.4 :scale 1)))
#+end_src

Extra completion:

#+begin_src emacs-lisp
(use-package cape
  :ensure t
  :commands (shou/text-mode-completions)
  :demand t

  :hook
  (text-mode . shou/text-mode-completions)

  :config
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)

  (defun shou/text-mode-completions ()
    (make-local-variable 'completion-at-point-functions)
    ;; add to the end
    (add-to-list 'completion-at-point-functions #'cape-dict t))

  ;; c.f. https://github.com/minad/corfu#completing-in-the-eshell-or-shell
  (when (version< emacs-version "29")
    ;; Silence the pcomplete capf, no errors or messages!
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-function'.
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)))
#+end_src

Show docs beside completion:

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :after corfu
  :hook (corfu-mode . shou/enable-corfu-popupinfo-conditionally)
  :ensure nil
  :bind (:map corfu-map
              ;; Scroll in the documentation window
              ("M-n" . #'corfu-popupinfo-scroll-up)
              ("M-p" . #'corfu-popupinfo-scroll-down)
              )
  :config
  (defun shou/enable-corfu-popupinfo-conditionally ()
    (when (not (display-graphic-p))
      (corfu-popupinfo-mode 1))))
#+end_src

Corfu completion in terminal:

#+begin_src emacs-lisp
(use-package corfu-terminal
  :unless (display-graphic-p)
  :ensure (corfu-terminal :host codeberg :repo "akib/emacs-corfu-terminal")
  :after corfu
  :hook (corfu-mode . corfu-terminal-mode))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  :ensure t
  :after recentf
  :bind
  (("M-g g" . consult-goto-line)
   ;; consult single line
   ("M-g M-g" . consult-line)
   ;; any org heading
   ("C-c C-S-j" . consult-org-agenda)
   ("C-x b" . consult-buffer)
   ("M-s L" . consult-line-multi)
   ("M-s m" . consult-global-mark)

   :map org-mode-map
   ;; org heading of this file
   ("C-c C-j" . consult-org-heading)
   )

  :custom
  ;; only show preview when pressing M-.
  (consult-preview-key "M-.")

  :config
  ;; show preview automatically for some commands
  (consult-customize
   consult-goto-line
   :preview-key '(:debounce 0.1 any))
  )

(use-package consult-lsp
  :ensure t
  :after lsp-mode
  :bind (:map lsp-mode-map
              ("C-c C-j" . consult-lsp-symbols)))
#+end_src

** CtrlF as isearch

#+begin_src emacs-lisp
(use-package ctrlf
  :ensure t
  :bind
  (("C-s" . ctrlf-forward-default)
   ("C-r" . ctrlf-backward-default)
   ("C-M-s" . ctrlf-forward-alternate)
   ("C-M-r" . ctrlf-backward-alternate)
   ("M-s _" . ctrlf-forward-symbol)
   ("M-s ." . ctrlf-forward-symbol-at-point))
)
#+end_src

** Comb key hints

I use =which-key= to display a screen of hints when a key prefix is entered.

#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :hook (emacs-startup . which-key-mode)
  :custom
  (which-key-idel-delay 1.5))
#+end_src

** Spell checker

I use =jinx= for spell check.

#+begin_src emacs-lisp
(use-package jinx
  :ensure t
  :bind (:map jinx-mode-map
              ("C-;" . jinx-correct))
  :hook
  (emacs-startup . global-jinx-mode)

  :custom
  (jinx-languages "en_US")
  (jinx-camel-modes '(prog-mode org-mode))

  :config
  (when (not (f-exists? "~/.config/enchant/enchant.ordering"))
    (f-mkdir-full-path "~/.config/enchant")
    (f-write "en_US:hunspell,aspell\n" 'utf-8
             "~/.config/enchant/enchant.ordering")
    (f-symlink (f-expand "~/.emacs.d/user-dict")
               "~/.config/enchant/en_US.dic"))

  :config
  (defun shou/jinx--add-to-abbrev (overlay choice)
    "Add word -> CHOICE to abbrev table. (word is under OVERLAY.)"
    (let ((word (buffer-substring-no-properties
                 (overlay-start overlay)
                 (overlay-end overlay))))
      (message "Abbrev: %s -> %s" word choice)
      (define-abbrev global-abbrev-table word choice)))

  (advice-add 'jinx--correct-replace :before #'shou/jinx--add-to-abbrev)

  ;; enable abbrev mode in jinx mode for auto-correction
  (add-hook 'jinx-mode-hook #'abbrev-mode)

  (defun shou/jinx-valid-english-possessive-p (start)
    (let ((word (buffer-substring-no-properties start (point))))
      (and (string-match-p "['’]s\\'" word)
           (cl-loop
            with word-stripped = (substring word 0 -2)
            for w in jinx--session-words
            thereis (and (string-equal-ignore-case word-stripped w)
                         (string-match-p "\\`[[:alpha:]]+\\'" w))))))

  (add-to-list 'jinx--predicates #'shou/jinx-valid-english-possessive-p))
#+end_src

** Snippets

I use =tempel= to quickly enter frequently used snippets.

#+begin_src emacs-lisp
(use-package tempel
  :ensure t
  :hook
  (text-mode . shou/add-tempel-to-capf)
  (prog-mode . shou/add-tempel-to-capf)

  :bind
  ("C-<tab>" . shou/tempel-expand-or-complete)

  (:map tempel-map
        ("<tab>" . tempel-next)
        ("<backtab>" . tempel-previous)
        ("S-<tab>" . tempel-previous))

  :custom
  ;; cannot be symlinked file because otherwise the auto-reload doesn't work.
  (tempel-path (f-canonical "~/.emacs.d/templates"))

  :config
  (defun shou/add-tempel-to-capf ()
    (make-local-variable 'completion-at-point-functions)
    (add-to-list 'completion-at-point-functions #'tempel-complete))


  ;; expand directly if there is an exact match, otherwise show candidates
  (defun shou/tempel-expand-or-complete ()
    (interactive)
    (if (tempel-expand)
        (tempel-expand t)
        (tempel-complete t)))

  (setq tempel-snippet-path (f-canonical "~/.emacs.d/snippets"))
  (defun shou/tempel-snippet (file)
    (f-read-text (f-join tempel-snippet-path file)))
  )
#+end_src

** Multi cursor support

#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-x m" . mc/mark-all-dwim)
         ("C-M-SPC" . mc/mark-next-lines)
         ("C->" . mc/mark-next-like-this-symbol)
         ("C-<" . mc/unmark-next-like-this)
         ("C-M->" . mc/skip-to-next-like-this)
         ("C-M-<" . mc/skip-to-previous-like-this))
  :config
  (define-key mc/keymap (kbd "<return>") nil))

;; multiple-cursors.el doesn't support isearch (or ctrlf), so we
;; need to use phi-search instead.
(use-package phi-search
  :ensure t
  :after multiple-cursors
  :bind
  (:map mc/keymap
        ("C-s" . phi-search)
        ("C-r" . phi-search-backward)))
#+end_src

** Visual query replace

#+begin_src emacs-lisp
(use-package visual-regexp
  :after multiple-cursors
  :ensure t
  :bind (("M-%" . vr/query-replace)))
#+end_src

** TRAMP

#+begin_src emacs-lisp
(use-package tramp
  :custom
  (tramp-default-method "scp")
  ;; cache file names for 10 seconds
  (remote-file-name-inhibit-cache 10)

  ;; do not store remote command history over tramp
  (tramp-histfile-override t)

  :config
  (defun shou/turn-off-project-detection ()
    (setq-local projectile-auto-update-cache nil)
    (setq-local projectile-dynamic-mode-line nil)
    (setq-local doom-modeline-project-detection nil))
  (add-hook 'tramp-mode-hook #'shou/turn-off-project-detection)
  )
#+end_src

** Sudo edit

#+begin_src emacs-lisp
(use-package sudo-edit
  :ensure t
  :commands (sudo-edit sudo-edit-find-file))
#+end_src

** O(1) jump around

#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind
  ("M-j" . avy-goto-char)
  ("M-J" . avy-pop-mark)

  :custom
  (avy-style 'at-full)

  :config
  ;; https://karthinks.com/software/avy-can-do-anything/#avy-plus-embark-any-action-anywhere
  (defun shou/def/avy-action-at-point (:key key :action f)
    "define custom avy action"
    (let ((avy-action-name
           (intern (concat "avy-action-" (symbol-name f)))))
      (progn
        (eval `(defun ,avy-action-name (pt)
                 (unwind-protect
                     (save-excursion (goto-char pt) (funcall ',f))
                   (select-window (cdr (ring-ref avy-ring 0))))
                 t))
        (eval `(setf (alist-get ,key avy-dispatch-alist) ',avy-action-name)))
    ))

  (shou/def/avy-action-at-point
   :key ?L
   :action 'shou/copy-idlink-to-clipboard)
  (shou/def/avy-action-at-point
   :key ?m
   :action 'embark-act)
  (shou/def/avy-action-at-point
   :key ?K
   :action 'kill-whole-line)
  )
#+end_src

** Embark

Pure keyboard context menu.

#+begin_src emacs-lisp
(use-package embark
  :ensure t
  :bind ("M-m" . embark-act)
  :config
  (defvar-keymap embark-identifier-map
    :doc "Actions on symbol"
    :parent embark-identifier-map
    "," 'xref-find-definitions
    "." 'xref-find-definitions-other-window
    ;; ("R" lsp-rename)
    "g" 'rg-dwim
    )
  )
#+end_src

** Pair management

I use =smartparens= package for (automatic) pair management.

#+begin_src emacs-lisp
(use-package smartparens-mode
  :ensure smartparens
  :bind (:map smartparens-mode-map
              ("M-r" . sp-rewrap-sexp)
              ("M-<down>" . sp-splice-sexp)
              ("M-S-<right>" . sp-forward-slurp-sexp)
              ("M-S-<left>" . sp-forward-barf-sexp)
              ("M-<right>" . sp-forward-sexp)
              ("M-<left>" . sp-backward-sexp))
  :hook prog-mode
  :custom
  (sp-autodelete-pair nil)
  (sp-autoinsert-pair nil)
  :config
  (require 'smartparens-config))
#+end_src

I'd also like to have a bit of visual hint for pair levels.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Nonlinear undo history

Undo-tree is good, but it sometimes slows down saving (uses too much memory), and I don't really need all its rich functionalities. Now I'm trying out =vundo= on emacs 28.

#+begin_src emacs-lisp
(use-package vundo
  ;; vundo requires emacs 28
  :ensure (vundo :host github :repo "casouri/vundo")
  :when (version<= "28" emacs-version)
  :bind ("C-x u" . vundo)
  :custom
  (vundo-compact-display t)
  )
#+end_src

** =keyfreq.el=

Gather statistics for frequently used commands.

#+begin_src emacs-lisp
(use-package keyfreq
  :ensure t
  :hook (emacs-startup . keyfreq-mode)
  :config
  (keyfreq-autosave-mode 1))
#+end_src

** Open a scratch buffer

Several differences from the default =*scratch-buffer*= (or =M-x scratch=)

1. the data is persistent across restarts, no loss of file content
2. you can open several scratch buffers as you want
3. it runs org mode by default

#+BEGIN_SRC emacs-lisp
(defun scratch ()
  "open a scratch buffer"
  (interactive)
  (let* ((buffer-name (make-temp-name "scratch-"))
         (buffer (generate-new-buffer buffer-name))
         (scratch-dir (f-expand "~/tmp/scratch"))
         (target-file (format "%s/%s.org" scratch-dir buffer-name)))
    (make-directory scratch-dir 'parents)
    (set (make-local-variable 'major-mode) 'org-mode)
    (switch-to-buffer buffer)
    (write-file target-file)
    (org-mode)))
#+END_SRC

** Code folding support

#+begin_src emacs-lisp
(use-package hs-minor-mode
  :ensure nil
  :hook (prog-mode . hs-minor-mode)
  :bind (:map hs-minor-mode-map
              ("C-c @ TAB" . hs-toggle-hiding)))
#+end_src

** Edit string at point

#+begin_src emacs-lisp
(use-package string-edit-at-point
  :ensure t
  :commands string-edit-at-point
  :bind (:map prog-mode-map
              ("C-c '" . string-edit-at-point)))
#+end_src

** Terminal UI

Copy to X clipboard:

#+begin_src emacs-lisp
(use-package xclip
  :ensure t
  :when (not (display-graphic-p))
  :hook (emacs-startup . xclip-mode))
#+end_src

Scroll with mouse wheel:

#+begin_src emacs-lisp
(use-package xterm-mouse-mode
  :ensure nil
  :when (not (display-graphic-p))
  :hook (emacs-startup . xterm-mouse-mode)
  )
#+end_src

* File management
** Basic config

#+begin_src emacs-lisp
(use-package dired
  :commands (dired dired-jump shou/copy-full-path)
  :bind (:map dired-mode-map
              ("." . dired-hide-dotfiles-mode)
              ("u" . diredp-up-directory)
              )
  :custom
  ;; Copy file to split window
  (dired-dwim-target t)
  ;; Always copy recursively
  (dired-recursive-copies 'always)
  ;; Ask once before deleting
  (dired-recursive-deletes 'top)
  ;; Show human readable size
  (dired-listing-switches "-lah")

  :config
  ;; used for deft
  (unbind-key "C-M-n" dired-mode-map)

  ;; dired-x.el is found in site-lisp
  (use-package dired-x :demand t)

  (defun shou/copy-full-path ()
    "Copy the full path of the current buffer to the kill ring."
    (interactive)
    (let ((path))
      (setq path
            (if (derived-mode-p 'dired-mode)
                (dired-get-filename)
              (buffer-file-name)))
      (if (not path)
          (message "full path not found: %s" (buffer-file-name))
        (message path)
        (kill-new path))))

  ;; copy full path of the current file
  (bind-key "W" #'shou/copy-full-path dired-mode-map)
  )
#+end_src

** dired+.el

#+begin_src emacs-lisp
;; loaded from site-lisp
(use-package dired+
  :after dired
  :demand t
  :init
  ;; do not show compressed files with face for ignored files
  ;; this variable must be set before dired+ is loaded because it affects font-lock
  (setq diredp-ignore-compressed-flag nil)

  :config
  ;; face customization
  (set-face-attribute 'diredp-dir-name nil :foreground "blue" :weight 'bold :background 'unspecified)
  (set-face-attribute 'diredp-ignored-file-name nil :foreground "darkgray")
  (set-face-attribute 'diredp-compressed-file-suffix nil :foreground 'unspecified :inherit 'diredp-compressed-file-name)
  (set-face-attribute 'diredp-file-suffix nil :foreground 'unspecified)
  (set-face-attribute 'diredp-file-name nil :foreground 'unspecified)
  (set-face-attribute 'diredp-write-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-read-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-exec-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-no-priv nil :background 'unspecified)
  (set-face-attribute 'diredp-dir-priv nil :background 'unspecified :foreground "blue")
  (set-face-attribute 'diredp-symlink nil :background 'unspecified :foreground "magenta")
  (set-face-attribute 'diredp-date-time nil :background 'unspecified :foreground "RoyalBlue")
  (set-face-attribute 'diredp-flag-mark-line nil :background "gray94" :weight 'bold)
  (set-face-attribute 'diredp-flag-mark nil :background 'unspecified :foreground "orange")
  (set-face-attribute 'diredp-omit-file-name nil :strike-through 'unspecified)

  (defun shou/update-dired+ ()
    "Download the latest version of dired+."
    (interactive)
    ;; download
    (url-copy-file
     "http://www.emacswiki.org/emacs/download/dired+.el"
     "~/.emacs.d/site-lisp/dired+.el"
     t)
    ;; rebuild
    (byte-compile-file "~/.emacs.d/site-lisp/dired+.el")
    ;; reload
    (unload-feature 'dired+ t)
    (require 'dired+ nil t)))
#+end_src

** Hide dot files by default

#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :ensure t
  :after dired
  :hook (dired-mode . dired-hide-dotfiles-mode))
#+end_src

* Tools
** Process manager

#+begin_src emacs-lisp
(use-package proced
  :custom
  (proced-enable-color-flag t))
#+end_src
* Org mode
** Base directory for org files

#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-directory "~/Documents/org")

  (defun org-file-path (filename)
    "Return the path of file inside org-directory"
    (expand-file-name filename org-directory))
  (setq org-default-notes-file (org-file-path "notes.org"))
  )
#+end_src

** To-do

#+begin_src emacs-lisp
(use-package org
  :bind ("C-c C-t" . org-todo)
  :custom
  ;; log todo done time
  (org-log-done 'time)
  ;; log toggle times into drawer
  (org-log-into-drawer t)

  ;; restore the red/green color
  (org-todo-keyword-faces
   '(("TODO" . "#a6b255")
     ("IN-PROG" . "#f2f9c1")
     ("TOREAD" . "#879434")
     ("WAIT" . "#c07993")))
  )
#+end_src

** Agenda

#+begin_src emacs-lisp
(use-package org
  :bind ("C-c a" . org-agenda)
  :custom
  (org-agenda-files `(,(org-file-path "projects.org")
                      ,(org-file-path "mencti.org")))

  ;; extend today to 3AM into next morning
  (org-extend-today-until 3)
  (org-use-effective-time t)

  ;; show agenda on the same window I launched it, otherwise it destroys my dedicated window setting
  (org-agenda-window-setup 'current-window)
  ;; do not start on weekdays
  (org-agenda-start-on-weekday nil)
  ;; do not show repeating items in future timeline
  (org-agenda-show-future-repeats t)
  ;; show today's agenda by default (instead of this week's)
  (org-agenda-span 'day)

  (org-agenda-sorting-strategy
   '((agenda category-keep habit-up priority-down todo-state-up time-up)
     (todo priority-down category-keep)
     (tags priority-down category-keep)
     (search priority-down category-keep)))

  (org-agenda-compact-blocks t)


  ;; skip filename as it takes up precious space and useless
  (org-agenda-prefix-format '((agenda . " %i  %?-12t% s")
                              (todo . " %i %-12:c")
                              (tags . " %i %-12:c")
                              (search . " %i %-12:c")))

  (org-agenda-custom-commands
   '(("d" "Daily agenda"
      ((agenda "" ((org-agenda-span 'day)))
       (todo "IN-PROG")))

     ("w" "Today's work agenda"
      ;; Please note that tags must go earlier than agenda, otherwise
      ;; a weird bug would invalidate the effect of org-agenda-tag-filter-preset
      ((tags "WORK/IN-PROG")
       (agenda "" ((org-agenda-span 'day)
                   (org-agenda-tag-filter-preset '("+WORK"))))))

     ("p" "Today's personal agenda"
      ((tags "PERSONAL/IN-PROG")
       (agenda "" ((org-agenda-span 1)
                   (org-agenda-tag-filter-preset '("+PERSONAL"))))))

     ("s" "Schedule view"
      ((tags "WORK/TODO"
             ((org-agenda-overriding-header "Work")
              (org-agenda-skip-function
               '(org-agenda-skip-entry-if 'scheduled 'deadline))))
       (tags "PERSONAL/TODO"
             ((org-agenda-overriding-header "Personal")
              (org-agenda-skip-function
               '(org-agenda-skip-entry-if 'scheduled 'deadline))))

       (tags "MENCTI/TODO"
             ((org-agenda-overriding-header "Mencti")
              (org-agenda-skip-function
               '(org-agenda-skip-entry-if 'scheduled 'deadline))))
       ))
     )))
#+end_src

** Insert heading at cursor

aka. disabling the feature that “smartly” insert heading after the current subtree.

#+begin_src emacs-lisp
(use-package org
  :bind
  (:map org-mode-map
	("C-<return>" . org-insert-heading)))
#+end_src

** Note taking

National Velocity-like experience with =deft=.

#+begin_src emacs-lisp
(use-package deft
  :ensure t
  :bind ("C-M-n" . deft)
  :commands (deft)
  :custom
  (deft-extensions '("org" "txt" "md" "markdown"))
  (deft-directory (org-file-path "random"))
  (deft-default-extension "org" "use org as default format")
  (deft-recursive t "search recursively")
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t "instead of some generated gibberish")
  (deft-auto-save-interval 60
    "don't auto save as it will reformat in middle of typing")
  (deft-file-naming-rules
    '((noslash . "-")
      (nospace . "-")
      (case-fn . downcase))
    "apply certain rules when generating file name")
  (deft-file-limit 40)
  )
#+end_src

** Capture templates

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind ("C-c c" . org-capture)
  :init
  (defun shou/org-select-project ()
    "Prompt for a location to select a headline"
    (interactive)
    (let* ((all-headings (-map 'car (org-refile-get-targets "projects.org")))
           (filtered-headings (--remove (member it '("Chore")) all-headings))
           (choice (completing-read "Select project: " filtered-headings)))
      (s-concat "::" choice)))

  (defun shou/org-time-stamp-string ()
    (s-with (with-temp-buffer (org-time-stamp nil)) (s-chop-prefix "<") (s-chop-suffix ">")))

  :custom
  (org-capture-templates
   `(("w" "Work" entry (file+headline "projects.org" "Work")
      "* TODO %^{Task (Work)}\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("p" "Personal" entry (file+headline "projects.org" "Personal")
      "* TODO %^{Task (Personal)}\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("v" "Video (<15 min)" entry (file+headline "mencti.org" "Videos (Short)")
      "* TODO %(org-cliplink-capture) %^g\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("V" "Video (>15 min)" entry (file+headline "mencti.org" "Videos (Long)")
      "* TODO %(org-cliplink-capture) %^g\n:PROPERTIES:\n:ADDED: %U\n:END:\n%?")
     ("a" "Article" entry (file+headline "mencti.org" "Articles")
      "* TODO %(org-cliplink-capture) %^g\n:PROPERTIES:\n:Effort: %^{prompt|0:10|0:30|1:00|2:00}\n:Added: %U\n:END:\n\n\n%?"
      )
     ("c" "Literature" entry (file+headline "mencti.org" "Literature")
      "* TODO %^{Literature name}\n:PROPERTIES:\n:Added: %U\n:END:\n\n\n%?"
      )
     ("l" "Log" entry (file "inbox.org")
      "* %(shou/org-time-stamp-string)\n:PROPERTIES:\n:Added: %U\n:END:\n\n\n%?"
      :jump-to-captured t
      )

     ("d" "Day planning" plain (file+olp+datetree "plan.org")
      ,(concat ":PROPERTIES:\n:ADDED: %U\n:END:\n"
               "cilre:\n- [ ]\n- [ ]\n"
               "chore:\n- [ ] vocab\n- [ ] diary\n"
               "sevzi:\n- [ ]\n"
               )
      :time-prompt t
      :immediate-finish t
      :jump-to-captured t
      )

     ("n" "News" item (file+olp+datetree "nuzba.org")
      "%^{News item}"
      :immediate-finish t)

     ("L" "Org protocol link" entry (file+headline "mencti.org" "Captures")
      "* TODO %:description\n:PROPERTIES:\n:ADDED: %U\n:END:\nSCHEDULED: %t\n%:link\n"
      :immediate-finish t)
     )))
#+END_SRC

** Refiling

#+begin_src emacs-lisp
(use-package org
  :custom
  (org-refile-targets '(("projects.org" . (:maxlevel . 9))
                        ("mencti.org" . (:level . 1))
                        ))

  ;; refile in one go
  (org-outline-path-complete-in-steps nil)

  ;; show full path
  (org-refile-use-outline-path 'file)
  )
#+end_src
** Org-store-link

I use =C-c l= to store link, and =C-c L= to store a id link to a heading.

#+begin_src emacs-lisp
(use-package org
  :bind
  ("C-c l" . org-store-link)
  ("C-c L" . shou/copy-idlink-to-clipboard)

  :config
  ;; Adapted from Rainer's blog:
  ;; https://koenig-haunstetten.de/2018/02/17/improving-my-orgmode-workflow/
  (defun shou/copy-idlink-to-clipboard()
    "Copy an ID link with the
headline to killring, if no ID is there then create a new unique
ID.  This function works only in org-mode or org-agenda buffers.

The purpose of this function is to easily construct id:-links to
org-mode items. If its assigned to a key it saves you marking the
text and copying to the killring."
    (interactive)
    (save-window-excursion
      (when (eq major-mode 'org-agenda-mode) ;switch to orgmode
        (org-agenda-show)
        (org-agenda-goto))
      (when (eq major-mode 'org-mode) ; do this only in org-mode buffers
        (let* ((head (nth 4 (org-heading-components)))
               ;; replace links with their description
               (clean-head (replace-regexp-in-string org-link-bracket-re "\\2" head))
               (id (funcall 'org-id-get-create))
               (link (format "[[id:%s][%s]]" id clean-head)))
          (kill-new link)
          (message "Copied %s to killring (clipboard)" link)
        )))))
#+end_src

** Clip link

Capture web page link and title.

#+begin_src emacs-lisp
(use-package org-cliplink
  :ensure t
  :after org
  :commands (org-cliplink-capture)
  :bind ("C-c C-S-l" . org-cliplink))
#+end_src

** Key to insert timestamp

Press F5 to insert current timestamp.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (defun shou/insert-timestamp ()
    (interactive)
    (insert (org-format-time-string "[%H:%M]: " (org-current-time))))
  (bind-key "<f5>" 'shou/insert-timestamp org-mode-map))
#+end_src

** Export support

I don't use any other export backends (e.g. ==odt=, =icalendar=).

#+begin_src emacs-lisp
(setq org-export-backends '(ascii html latex))
#+end_src

I use pandoc for exporting to mediawiki and gfm.

#+begin_src emacs-lisp
(use-package ox-pandoc
  :ensure t
  :after ox
  :demand t ;; required for registering org-export-dispatch
  :custom
  (org-pandoc-menu-entry
   '(
     (?w "as mediawiki." org-pandoc-export-as-mediawiki)
     (?g "as gfm." org-pandoc-export-as-gfm)
     ))
  (org-pandoc-options-for-mediawiki '((shift-heading-level-by . "1")))
  (org-pandoc-options-for-gfm '((shift-heading-level-by . "1")
                                (wrap . "none")))
  :config
  (defun shou/ox-mediawiki-transform ()
    "Transform the current buffer to meet my ideal mediawiki format."
    ;; 1. remove the inserted <span id=xxx></span>
    (goto-char (point-min))
    (while (re-search-forward "<span id=\"[0-9a-z-]+\"></span>" nil t)
      (replace-match ""))

    ;; 2. convert org dates like [2023-06-21 Wed] into [[Jun 21, 2023]]
    (goto-char (point-min))
    (while (re-search-forward org-ts-regexp-inactive nil t)
      (let* ((ts (match-string 0))
             (parsed (save-match-data (org-parse-time-string ts)))
             (encoded (encode-time parsed))
             (formatted (format-time-string "[[%b %-d, %Y]]" encoded)))
        (replace-match formatted)))

    ;; restore cursor
    (goto-char (point-min)))

  (add-hook 'org-pandoc-after-processing-mediawiki-hook
            'shou/ox-mediawiki-transform))

(use-package ox
  :config
  ;; allow exporting broken links
  (setq org-export-with-broken-links 'mark))
#+end_src

** Org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :ensure t
  :after org
  :hook (emacs-startup . global-org-modern-mode)
  :config
  ;; align agenda tags to the right at 80 column
  (setq org-agenda-tags-column -80
        org-agenda-block-separator ?─)

  ;; label should have the same size as normal text
  ;; as not to screw up table alignment.
  (set-face-attribute 'org-modern-label nil
                      :inherit 'fixed-pitch
                      :height 'unspecified)

  ;; do not replace checkbox
  (setq org-modern-checkbox nil)

  ;; the original level-2 star doesn't look good in my font.
  (setq org-modern-star '("◉" " ○" "  ◆" "   ◇" "    ▶" "     ▷"))

  ;; task completion progress indicator
  ;; or "●"
  (setq org-modern-progress '("○" "◔" "◑" "◕" "✓"))

  ;; do not prettify block names
  (setq org-modern-block-name nil)

  ;; do not prettify keywords like (title, result, etc)
  (setq org-modern-keyword nil)

  ;; do not prettify tables
  (setq org-modern-table nil)

  ;; customize the list bullets
  (setq org-modern-list '((?+ . "◦")
                          (?- . "•")
                          (?* . "‣")))

  ;; make inactive date appear less contrastive than active date
  (set-face-attribute 'org-modern-date-inactive nil
                      :foreground "gray60"))
#+end_src

*** Use valign mode for pixel-perfect table alignment

#+begin_src emacs-lisp
(use-package valign
  :disabled
  :ensure t
  :hook (org-mode . valign-mode)
  :custom (valign-fancy-bar t))
#+end_src

** Spot weaselwords

#+begin_src emacs-lisp
(use-package writegood-mode
  :ensure t
  :hook (org-mode . writegood-mode))
#+end_src

** Math symbols in Tex input method

#+begin_src emacs-lisp
(use-package quail
  :ensure nil
  :config
  (with-temp-buffer
    ;; the input method has to be triggered for `quail-package-alist' to be non-nil
    (activate-input-method "TeX")
    (let ((quail-current-package (assoc "TeX" quail-package-alist)))
      (quail-define-rules ((append . t))
                          ("\\and" ?∧)
                          ("\\or" ?∨)))))
#+end_src
* Programming features
** Source control

*** Magit

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :bind
  ("C-x g" . magit)
  ("C-x C-g" . magit-file-dispatch)

  :custom
  ;; https://twitter.com/iLemming/status/1243322552828571649
  (magit-save-repository-buffers 'save-all-and-dont-ask)

  ;; sort branches (or any refs) by creation date
  (magit-list-refs-sortby "-creatordate")

  ;; greatly improve scrolling performance on large diffs
  ;; c.f. https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag
  (auto-window-vscroll nil)

  :config
  ;; so it don't close other windows
  (fset 'magit-restore-window-configuration (lambda (x) (kill-buffer-and-window)))
  ;; automatically refresh after saving a file
  ;;
  ;; Edit: I turned it off as it makes editing a bit laggy. Now please
  ;; press 'g' manually to refresh.
  ;;
  ;; (add-hook 'after-save-hook 'magit-after-save-refresh-status t)

  ;; do not override projectile keys
  (unbind-key "M-p" magit-status-mode-map)
  (unbind-key "M-n" magit-status-mode-map)

  ;; do not show list of tags to faster
  ;; (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)
  (add-to-list 'magit-section-initial-visibility-alist
               '([tags branchbuf] . hide))

  ;; show exact date on revision page
  (setq magit-revision-headers-format (->> magit-revision-headers-format
                                           (s-replace "%ad" "%ad (%aD)")
                                           (s-replace "%cd" "%cd (%cD)")))
  )
#+end_src

*** Forge

Online features, PR, issues, etc.

Hotkey to remember:

| =C-c C-o= | forge-browse-topic |
| =C-c C-e= | edit field dwim    |

#+begin_src emacs-lisp
(use-package forge
  :ensure t
  :after magit
  :bind (:map magit-mode-map
              ("M-W" . forge-copy-url-at-point-as-kill))
  :custom-face
  ;; The status (unread/read) affects the boldness of the text, while
  ;; the state (open/close) affects the text color (normal/dimmed).
  (forge-topic-unread ((t (:foreground nil))))
  :config
  ;; '(githost apihost id class)
  (add-to-list 'forge-alist
               '("git.lain.li"
                 "git.lain.li/api/v1"
                 "git.lain.li"
                 forge-gitea-repository))
  )
#+end_src

*** Ediff

#+begin_src emacs-lisp
(use-package ediff
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally)
  (ediff-keep-variants nil)
  :config
  ;; quit immediately without asking
  ;; https://emacs.stackexchange.com/questions/9322/how-can-i-quit-ediff-immediately-without-having-to-type-y
  (defun disable-y-or-n-p (orig-fun &rest args)
    (cl-letf (((symbol-function 'y-or-n-p) (lambda (prompt) t)))
      (apply orig-fun args)))

  (advice-add 'ediff-quit :around #'disable-y-or-n-p))
#+end_src

*** Browse on GitHub

#+begin_src emacs-lisp
(use-package browse-at-remote
  :ensure t
  :bind (("C-c g g" . browse-at-remote)
         ("C-c g G" . browse-at-remote-kill)
         ;; mimic "open-at-point" behaviour
         :map prog-mode-map
         ("C-c C-o" . browse-at-remote)))
#+end_src

*** Better diff with =delta=

Delta supports highlighting language-syntax, within-line diff, etc.

#+begin_src emacs-lisp
(use-package magit-delta
  :ensure t
  :if (executable-find "delta")
  :hook (magit-mode . magit-delta-mode))
#+end_src

*** Git auto commit

I automatically backup my org files using git after idle for a
while. The mode is activated for specific folder only using
=.dir-locals.el=.

#+begin_src emacs-lisp
(use-package git-auto-commit-mode
  :ensure t
  :commands git-auto-commit-mode
  :custom
  ;; auto push to remote
  (gac-automatically-push-p t)
  ;; only backup after 120 secs
  (gac-debounce-interval 120)
  ;; do not prompt for gpg signature
  (gac-commit-additional-flag "--no-gpg-sign"))
#+end_src

** Project management

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :custom
  (projectile-completion-system #'completing-read)
  (projectile-enable-caching nil)
  (projectile-indexing-method 'alien)
  (projectile-globally-ignored-file-suffixes '("beam"))
  (projectile-create-missing-test-files t)
  ;; speed up tramp (https://emacs.stackexchange.com/questions/17543/tramp-mode-is-much-slower-than-using-terminal-to-ssh)
  (projectile-mode-line "P")
  (projectile-switch-project-action 'shou/action-after-switch-project)
  (projectile-track-known-projects-automatically nil)

  :hook (emacs-startup . projectile-mode)
  :bind-keymap
  ("M-`" . projectile-command-map)

  :config
  (setq projectile-globally-ignored-directories
        (append projectile-globally-ignored-directories
                '(".elixir_ls" "_build")))

  ;; Elixir: jump to *_test.exs instead of *_test.ex
  (defun shou/fix-exs-test-file-name (name)
    (cond
     ((string-suffix-p "_test.ex" name) (concat name "s"))
     (t name)))

  (advice-add #'projectile--test-name-for-impl-name
              :filter-return
              #'shou/fix-exs-test-file-name)

  (defun shou/action-after-switch-project ()
    "open magit or prompt for find file"
    (if (and (fboundp 'magit-git-repo-p)
             (magit-git-repo-p default-directory))
        (magit)
        (projectile-find-file)))
  )
#+end_src

*** Find marker file

#+begin_src emacs-lisp
(with-eval-after-load 'projectile
  (defun shou/projectile-find-marker-file ()
    "Find the marker file (Cargo.toml, mix.exs, etc) for the current project."
    (interactive)
    (if-let* ((this-file (buffer-file-name))
              (marker-files (projectile-project-type-attribute
                             (projectile-project-type)
                             'marker-files))
              (get-target-marker-file
               (lambda (f)
		 (when-let* ((dir (locate-dominating-file default-directory f))
                             (full-path (concat dir f))
                             (_ (not (f-same-p this-file full-path))))
                   full-path)))
              (marker-file (seq-find get-target-marker-file marker-files))
              (target-marker-file (funcall get-target-marker-file marker-file)))
	(find-file target-marker-file)
      (if-let* ((default-directory (f-dirname default-directory))
		(parent-marker-file (seq-find get-target-marker-file marker-files))
		(target-parent-marker-file (funcall get-target-marker-file parent-marker-file)))
          (find-file target-parent-marker-file)
	(message "No marker file found"))))

  (bind-key "m" 'shou/projectile-find-marker-file projectile-command-map))
#+end_src

*** ripgrep (=rg=)

I don’t use =deadgrep= any more. =rg= + =wgrep= is better in terms of speed and the display is nicer.

Few shortcuts:

- press =C-c s s= to search current word
- on search window, =m= to bring up the menu (refine search, change dir, etc)
- on search window, =C-x C-q= to enable =wgrep= editing mode

#+begin_src emacs-lisp
(use-package rg
  :ensure t
  :bind (("C-c s s" . rg-dwim)
         ("C-c s p" . rg-project)
         ("C-c s r" . rg)
         ("C-c s t" . rg-literal)
         :map rg-mode-map
         ("C-x C-q" . wgrep-change-to-wgrep-mode))
  :custom
  ;; find when use
  (wgrep-auto-save-buffer t)
  ;; trade parallelism for determinism in the ordering
  (rg-command-line-flags '("-j1"))

  :config
  (defun shou/switch-to-rg-buffer (&rest args)
    (switch-to-buffer-other-window "*rg*"))
  (advice-add 'rg-run :after #'shou/switch-to-rg-buffer)
  )
#+end_src

*** Load editor config

Mostly to load indentation settings.

#+begin_src emacs-lisp
(use-package editorconfig
  :hook (prog-mode . editorconfig-mode)
  :ensure t)
#+end_src

*** Guess tab size

#+begin_src emacs-lisp
(use-package dtrt-indent
  :hook (prog-mode . dtrt-indent-mode)
  :ensure t
  :config
  ;; I sometimes type when I forget how to spell "dtrt"
  (defalias 'detect-indentation 'dtrt-indent-mode)
  (defalias 'detect-tab-size 'dtrt-indent-mode)
  (defalias 'dets 'dtrt-indent-mode)
  )
#+end_src

** Language server protocol (LSP)

#+begin_src emacs-lisp
(use-package lsp-mode
  :ensure t
  :init
  ;; to fix a weird bug
  (setq lsp-keymap-prefix "M-l")

  :commands (lsp lsp-mode)
  :bind (:map lsp-mode-map
              ("C-c C-f" . lsp-format-buffer)
              ("M-," . xref-find-definitions)
              ("M-." . xref-find-definitions-other-window)
              :map lsp-command-map
              ("l" . lsp-inlay-hints-mode))

  :bind-keymap
  ("M-l" . lsp-command-map)

  :hook
  ;; enable LSP on these modes
  (rust-mode . lsp-deferred)

  :custom
  ;; use Corfu!
  (lsp-completion-provider :none)

  ;; use flycheck
  (lsp-diagnostics-provider :flycheck)

  ;; do not show debug messages that tend to be long (turn off for debugging)
  ;; example: rust-analyzer crash message
  (lsp--show-message nil)

  ;; 1 sec or fail
  (lsp-response-timeout 1.0)

  ;; do not expect yasnippet is installed
  (lsp-enable-snippet nil)

  ;; place lens above a line instead at the end of a line
  (lsp-lens-place-position 'above-line)

  ;; performance tuning
  (read-process-output-max (* 1 1024 1024)) ;; 20mb

  ;; only sort by position
  (lsp-imenu-sort-methods '(position kind name))
  (lsp-imenu-show-container-name t)

  ;; do not show breadcrumb
  (lsp-headerline-breadcrumb-enable nil)

  ;; do not auto configure dap-mode unless I explicitly asked for it.
  ;; otherwise it starts dap-tooltip-mode which interfere with the corfu popup.
  (lsp-enable-dap-auto-configure nil)

  ;; make inlay hint ready for toggle with lsp-inlay-hint-mode
  (lsp-inlay-hint-enable nil)

  ;; only load clients that I actually need
  (lsp-client-packages
   '(lsp-elixir
     lsp-rust
     lsp-pylsp
     lsp-javascript
     lsp-css
     lsp-json
     lsp-nix
     ))

  ;; do not execute single action automatically. let me see what actions are available.
  (lsp-auto-execute-action nil)

  ;; show multiline type info
  (lsp-eldoc-render-all t)
  ;; do not show truncated message
  (eldoc-echo-area-display-truncation-message nil)

  ;; jump to reference instead of showing a list of references
  (lsp-xref-force-references t)

  :config
  ;; see https://github.com/minad/corfu/wiki#basic-example-configuration-with-orderless
  (defun shou/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless))) ;; Configure orderless
  (add-hook 'lsp-completion-mode-hook 'shou/lsp-mode-setup-completion)

  ;; exclude unwanted watch files
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\.elixir_ls")
  (add-to-list 'lsp-file-watch-ignored "\\.beam\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]_build\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]deps\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "\\.lean\\'")

  ;; override default lsp-xref backend
  ;; (add-hook 'lsp-mode-hook 'insert-dumb-jump-to-xref)

  (add-hook 'lsp-mode-hook 'lsp-enable-which-key-integration)

  ;; disable lsp-modeline-diagnostics-mode
  (add-hook 'lsp-mode-hook (lambda () (lsp-modeline-diagnostics-mode -1)))

  ;; conflict with projectile prefix
  (unbind-key "M-p" lsp-signature-mode-map)
  ;; unbind it as well as I never bother using it.
  (unbind-key "M-n" lsp-signature-mode-map)

  ;; fallback to dumb-jump if lsp can't find defn
  ;; copied from https://github.com/hlissner/doom-emacs/issues/4662#issuecomment-780911875
  (defun lsp-find-definition-or-dumb-jump ()
    (interactive)
    (let ((loc (lsp-request "textDocument/definition"
                            (lsp--text-document-position-params))))
      (if (seq-empty-p loc)
          (lsp-show-xrefs (lsp--locations-to-xref-items loc) nil nil)
        (dumb-jump-go))))

  ;; See https://github.com/minad/corfu/issues/188#issuecomment-1148658471
  (with-eval-after-load 'cape
    (advice-add #'lsp-completion-at-point :around #'cape-wrap-noninterruptible))

  (defun shou/add-lsp-next-checker (checker)
    (setq shou/flycheck-local-cache
          `((lsp . ((next-checkers . (,checker)))))))

  (message "lsp loaded")
  )
#+end_src

*** JSON parsing performance boost

https://github.com/blahgeek/emacs-lsp-booster

#+begin_src emacs-lisp
(use-package lsp-mode
  :when (executable-find "emacs-lsp-booster")
  :config
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command))
#+end_src

** Terminal and shell
*** Eshell

#+begin_src emacs-lisp
(use-package eshell
  :bind
  ("C-x e" . eshell)

  :custom
  (eshell-history-size 10240)
  (eshell-last-dir-ring-size 512)

  :preface
  (defun shou/def-eshell-alias (name def)
    (when (not (equal (eshell-lookup-alias name)
                      `(,name ,def)))
      (eshell/alias name def)))

  :config
  (setenv "KUBECONFIG"
          (s-join ":" (-map 'f-expand
                            (cons "~/.kube/config" (f-glob "~/.kube/config.d/*")))))

  (defun shou/eshell-insert-history-element ()
    (interactive)
    (insert (completing-read "Search history: " (ring-elements eshell-history-ring))))

  (defun shou/eshell-insert-arguments-from-previous-command ()
    "Bring up the arguments from the previous command. Similar to M-. in shell."
    (interactive)
    (let ((begin))
      (save-excursion
		    (eshell-previous-prompt 1)
        ;; to ensure the cursor lands on the beginning of word
        (eshell-forward-argument 1)
        (eshell-forward-argument 1)
        (eshell-backward-argument 1)
		    (setq begin (point))
        (end-of-line)
        (kill-ring-save begin (point)))
      (yank)))

  (defun shou/eshell-customization ()
    ;; use the cape's file completion instead of the default
    ;; pcomplete's.
    (make-local-variable 'completion-at-point-functions)
    (add-to-list 'completion-at-point-functions #'cape-file)

    ;; colorize command line tool outputs
    ;; stolen from https://old.reddit.com/r/emacs/comments/b6n3t8/what_would_it_take_to_get_terminal_colors_in/
    (setenv "TERM" "xterm-256color")

    ;; bash-like history search
    (bind-key "M-r" #'shou/eshell-insert-history-element eshell-mode-map)
    (bind-key "M-r" #'shou/eshell-insert-history-element eshell-hist-mode-map)
    (bind-key "M-." #'shou/eshell-insert-arguments-from-previous-command eshell-mode-map)

    ;; eshell-lookup-alias is defined buffer-locally
    (shou/def-eshell-alias "ll" "ls -al $*")
    (shou/def-eshell-alias "k" "kubectl $*")
    (shou/def-eshell-alias "z" "kubectl $*"))

  (add-hook 'eshell-mode-hook #'shou/eshell-customization)

  ;; eshell aliases
  (fset 'eshell/vi #'find-file)
  (fset 'eshell/ff #'find-file)

  (defun eshell/z (&optional regexp)
    "fasd-like cd"
    (if (not regexp)
        (eshell/cd "=")
      (eshell/cd (format "=%s" regexp))))
  )
#+end_src

*** Enhanced shell command completion

Add more command completions for various command line utilities.

#+begin_src emacs-lisp
(use-package pcmpl-args
  :ensure t
  :after eshell
  :init
  ;; pcmpl should require this but didn't
  (require 'pcmpl-gnu))
#+end_src

*** Jump to current eshell instance

#+begin_src emacs-lisp
(with-eval-after-load 'eshell
  (defun shou/advice-eshell (orig-fun &rest args)
    "Advice to make `eshell' reuse existing eshell for the same directory."
    (let* ((eshell-buffers (seq-filter
                            (lambda (b)
                              (eq (buffer-local-value 'major-mode b) 'eshell-mode))
                            (buffer-list)))
           (eshell-buffer (seq-find
                           (lambda (b)
                             (string= (buffer-local-value 'default-directory b)
                                      default-directory))
                           eshell-buffers)))
      (if eshell-buffer
          (let ((eshell-buffer-name (buffer-name eshell-buffer)))
            (apply orig-fun args))
	(apply orig-fun args))))

  (advice-add 'eshell :around #'shou/advice-eshell))
#+end_src

*** Terminal

Some programs requires a more POSIX compatible terminal software. I use =eat= for this.

#+begin_src emacs-lisp
(use-package eat
  :ensure '(eat :type git
                  :host codeberg
                  :repo "akib/emacs-eat"
                  :files ("*.el" ("term" "term/*.el") "*.texi"
	                        "*.ti" ("terminfo/e" "terminfo/e/*")
	                        ("terminfo/65" "terminfo/65/*")
	                        ("integration" "integration/*")
	                        (:exclude ".dir-locals.el" "*-tests.el")))
  :commands (eat eat-eshell-mode eat-project)
  :after projectile
  :bind
  ("C-x E" . eat)
  (:map projectile-command-map
   ("x E" . shou/eat-projectile))
  :hook
  (eshell-load . eat-eshell-mode)
  (eshell-load . eat-eshell-visual-command-mode)
  :custom
  ;; unlimited scrollback
  (eat-term-scrollback-size nil)
  :config
  (defun shou/eat-projectile (arg)
    (interactive "P")
    (require 'projectile)
    (let ((project (projectile-acquire-root)))
      (projectile-with-default-dir project
        (let ((eat-buffer-name
               (projectile-generate-process-name "eat" arg project)))
          (eat nil arg)))))

  ;; allow switching file via projectile (M-`)
  (add-to-list 'eat-semi-char-non-bound-keys [?\e ?`])
  (add-to-list 'eat-semi-char-non-bound-keys [C-n])
  (add-to-list 'eat-semi-char-non-bound-keys [C-p])
  (eat-update-semi-char-mode-map))
#+end_src

*** Send to external tmux session

Use commands like =emamux:send-buffer=.

#+begin_src emacs-lisp
(use-package emamux
  :ensure t
  :commands (emamux:send-buffer emamux:send-region))
#+end_src

** Jump to definition

I use =dumb-jump=, which works out of the box for many languages. I
prioritize =lsp-mode= find-definition function if it works,
otherwise fallback to =dumb-jump=.

#+begin_src emacs-lisp
(use-package dumb-jump
  :ensure t
  :functions (dumb-jump-xref-activate)
  :custom
  (dumb-jump-selector 'completing-read)
  (dumb-jump-force-searcher 'rg)
  ;; Defaults to --pcre2. ripgrep's pcre is an opt-in feature that's not enabled by default.
  (dumb-jump-rg-search-args "--auto-hybrid-regex")
  :init
  (require 'xref)
  (remove-hook 'xref-backend-functions #'etags--xref-backend)
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)

  ;; Do not show a *xref* buffer when there are multiple
  ;; candidates. Show a completion buffer instead.
  (when (fboundp 'xref-show-definitions-completing-read)
    (setq xref-show-definitions-function #'xref-show-definitions-completing-read)))

(with-eval-after-load 'xref
  (bind-key* "M-," #'xref-find-definitions)
  (bind-key* "M-." #'xref-find-definitions-other-window)
  (bind-key* "M-?" #'xref-find-references))
#+end_src

** On-the-fly check

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :commands flycheck-mode
  :hook (prog-mode . flycheck-mode)

  :preface
  ;; adapted from
  ;; https://github.com/flycheck/flycheck/issues/1762#issuecomment-750458442
  (defvar-local shou/flycheck-local-cache nil)

  (defun shou/flycheck-checker-get (fn checker property)
    (or (alist-get property (alist-get checker shou/flycheck-local-cache))
        (funcall fn checker property)))

  (advice-add 'flycheck-checker-get :around 'shou/flycheck-checker-get)

  :custom
  ;; do not recheck syntax on newline or on save, which can result in
  ;; perceivable lagging.
  (flycheck-check-syntax-automatically '(mode-enable idle-change))
  ;; only check syntax after 4 seconds of idling
  (flycheck-idle-change-delay 4)

  :config
  ;; add frequent typo
  (define-key flycheck-mode-map (kbd "C-c 1") flycheck-command-map))
#+end_src

** Sideline

#+begin_src emacs-lisp
(use-package sideline
  :ensure t
  :custom
  ;; show sideline immediately
  (sideline-delay 0)
  :hook
  (flycheck-mode . sideline-mode)
  (lsp-mode . sideline-mode)
  :config
  (setq sideline-backends-right '(sideline-lsp sideline-flycheck))
  )

(use-package sideline-flycheck
  :ensure t
  :after (flycheck sideline)
  :hook (flycheck-mode . sideline-flycheck-setup))
(use-package sideline-lsp
  :ensure t
  :after flycheck lsp-mode)

(use-package sideline-lsp
  :after lsp-modeline
  :demand t
  :config
  ;; the default code action prefix is the unicode emoji char "💡" (U+1F4A1).
  ;; Because of some reason it my Noto Color Emoji font cannot be specified
  ;; so the default font fallbacks to Symbola. Symbola has a different height
  ;; than my default font, so whenever the sideline shows up, the lineheight
  ;; would shift a bit, causing a uncomfortable visual twitch. To fix this,
  ;; I just simply copy the icon from the lsp-mode's modeline, which uses
  ;; all-the-icons under the hood.
  (setq sideline-lsp-code-actions-prefix
        (concat
         (lsp-modeline--code-actions-icon 'lsp-modeline-code-actions-face)
         " "))
  )
#+end_src

** Highlight all occurrences of word at point

#+begin_src emacs-lisp
(use-package idle-highlight-mode
  :disabled
  :ensure t
  :hook (prog-mode . idle-highlight-mode)
  :custom
  (idle-highlight-idle-time 0.5))
#+end_src

** Compilation mode

#+begin_src emacs-lisp
(setq compilation-scroll-output 'first-error)

;; colorize using ansi color
(require 'ansi-color)
(add-hook 'compilation-filter-hook
          (lambda ()
            (let ((inhibit-read-only t))
              (ansi-color-apply-on-region compilation-filter-start (point)))))
#+end_src

** Code formatting

#+begin_src emacs-lisp
(use-package apheleia
  :ensure t
  :hook (emacs-startup . apheleia-global-mode)
  :config
  (add-to-list 'apheleia-formatters '(mix . ("mix" "format" "-")))
  (add-to-list 'apheleia-formatters '(prettier . (npx "prettier" "--stdin-filepath" filepath)))
  (add-to-list 'apheleia-formatters '(rustfmt . ("rustfmt" "--quiet" "--emit" "stdout")))

  (add-to-list 'apheleia-mode-alist '(elixir-mode . mix))

  ;; See https://github.com/raxod502/apheleia/issues/30
  (defun shou/fix-apheleia-project-dir (orig-fn &rest args)
    (let ((project (project-current)))
      (if (not (null project))
          (let ((default-directory (projectile-project-root))) (apply orig-fn args))
        (apply orig-fn args))))

  (advice-add 'apheleia-format-buffer :around #'shou/fix-apheleia-project-dir)

  ;; sometimes apheleia erase the whole buffer, which is pretty annoying.
  ;; fix it by detecting this scenario and simply doing no-op
  (defun shou/fix-apheleia-accidental-deletion
      (orig-fn old-buffer new-buffer &rest rest)
    (if (and (=  0 (buffer-size new-buffer))
             (/= 0 (buffer-size old-buffer)))
        ;; do not override anything
        nil
        (apply orig-fn old-buffer new-buffer rest)))

  (advice-add 'apheleia--create-rcs-patch :around #'shou/fix-apheleia-accidental-deletion)

  ;; used in hooks to turn off apheleia mode for some modes
  (defun shou/disable-apheleia-mode nil (apheleia-mode -1)))
#+end_src

** Treesit

Configure the built-in tree sit modes.

#+begin_src emacs-lisp
(use-package treesit
  :when (version<= "29.1" emacs-version)
  :custom
  (major-mode-remap-alist
   '((toml-mode . toml-ts-mode)
     ;; treesit-install-grammar https://github.com/tree-sitter/tree-sitter-css
     (css-mode . css-ts-mode)
     )))
#+end_src

** Highlighting TODOs

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure (:depth nil)
  :custom
  (hl-todo-keyword-faces
   '(("TODO" . "#721045")
     ("FIXME" . "#a0132f")
     ("HACK" . "#813e00"))))
#+end_src

*** List TODOs in consult

#+begin_src emacs-lisp
(use-package consult-todo
  :ensure t
  :after (magit hl-todo))
#+end_src

*** List TODOs in magit

#+begin_src emacs-lisp
(use-package magit-todos
  :ensure t
  :after (magit hl-todo)
  :config (magit-todos-mode 1))
#+end_src

* Auto-completion
** copilot.el

#+begin_src emacs-lisp
(use-package copilot
  :ensure (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
  :commands (copilot-mode copilot-clear-overlay copilot-complete copilot-diagnose)
  :custom
  ;; enable logging (max size: 10000)
  (copilot-log-max 100)
  (copilot-idle-delay 0.3)

  :init
  ;; keys bind to copilot-completion-map
  (setq shou/copilot-keymap
        '(("C-e" . copilot-accept-completion)
          ("M-f" . copilot-accept-completion-by-word)
          ("C-g" . copilot-clear-overlay)))

  :bind
  ;; C-S-tab
  (("C-<iso-lefttab>" . copilot-complete))

  :hook
  (text-mode . copilot-mode)
  (conf-mode . copilot-mode)
  (prog-mode . copilot-mode)

  :config
  (defun shou/buffer-file-name ()
    (or (buffer-file-name)
        (and (buffer-base-buffer)
             (buffer-file-name (buffer-base-buffer)))
        (buffer-name)
        ""))

  (defun shou/copilot-disable-predicate ()
    (or
     ;; do not enable copilot when i'm editing wiki
     (derived-mode-p 'mediawiki-mode)
     ;; do not enable copilot on files that may contain secrets
     (string-match-p "\\(?:secret\\|cred\\|hidden\\|private\\|auth\\|app-2024\\)"
                     (shou/buffer-file-name))
     ;; do not enable copilot on gpg files
     (string-match-p "\\.\\(gpg\\|asc\\)\\'"
                     (shou/buffer-file-name))
     (string-match-p "\\.bean\\'"
                     (shou/buffer-file-name))
     ;; do not enable copilot on files in tmp/cu
     (string-match-p "tmp/cu" (shou/buffer-file-name))
     ;; do not match server files
     (string-match-p "examples/server" (shou/buffer-file-name))
     ))
  (add-to-list 'copilot-disable-predicates #'shou/copilot-disable-predicate)

  (defun shou/advice-copilot-mode (orig-fn &rest args)
    (when (not (shou/copilot-disable-predicate))
      (apply orig-fn args)))
  (advice-add 'copilot-mode :around #'shou/advice-copilot-mode)

  ;; copilot-completion-map doesn't always trigger when flymake
  ;; overlay is present at the same position. So I wrote this
  ;; workaround to bind the keys to copilot-map and only trigger
  ;; copilot-functions when the overlay is visible.
  (defun shou/copilot-override-key (key f)
    "Only execute copilot f key if copilot overlay is visible"
    (if (copilot--overlay-visible)
        (funcall f)
      (let ((copilot-mode nil))
        ;; fallback to default behavior
        (call-interactively (key-binding key)))))

  (cl-loop for (key . f) in shou/copilot-keymap
           do
           (message "binding %s to %s" key f)
           (bind-key key f copilot-completion-map)
           (bind-key key `(lambda () (interactive)
                            (shou/copilot-override-key ,(kbd key) (quote ,f)))
                     copilot-mode-map))


  ;; silent the warning: https://github.com/copilot-emacs/copilot.el/issues/220
  (defun shou/ignore-copilot-indent-warning ()
    (setq-local copilot--indent-warning-printed-p t))
  (add-hook 'copilot-mode-hook #'shou/ignore-copilot-indent-warning))
#+end_src

*** copilot fix with org-todo

See https://github.com/copilot-emacs/copilot.el/issues/172.

#+begin_src emacs-lisp
(use-package copilot
  :disabled
  :after org
  :config
  (defun shou/disable-copilot-temporarily (fn &rest args)
    (if (not (and (boundp 'copilot-mode) copilot-mode))
        (apply fn args)
      (copilot-mode -1)
      (apply fn args)
      (save-restriction
        (widen)
        (copilot-mode 1))))

  ;; advice it on org-todo
  (advice-add 'org-todo :around #'shou/disable-copilot-temporarily)
  ;; used in org-indent-item/org-outdent-item/org-cycle-list-bullet
  (advice-add 'org-list-struct-apply-struct :around #'shou/disable-copilot-temporarily))
#+end_src

** gptel

Press =C-c <RET>= to send your input.

#+begin_src emacs-lisp
(use-package gptel
  :ensure (:host github :repo "karthink/gptel")
  :commands (gptel-send gptel gptel-menu gptel-set-topic)
  :custom
  (gptel-default-mode 'org-mode)
  (gptel-log-level 'info)
  :config
  ;; auto scroll as the response comes in
  (add-hook 'gptel-post-stream-hook 'gptel-auto-scroll)
  ;; move cursor to the end of response
  (add-hook 'gptel-post-response-hook 'gptel-end-of-response)

  ;; openrouter.ai as default backend
  (require 'shou-pass)
  (gptel-make-openai "Openrouter.ai"
    :models '("gryphe/mythomist-7b" "recursal/eagle-7b" "undi95/toppy-m-7b")
    :stream t
    :key (lambda nil (shou/get-pass-entry "openrouter-ai/api-key"))
    :host "openrouter.ai"
    :endpoint "/api/v1/chat/completions"
    ))
#+end_src

** ancilla.el

#+begin_src emacs-lisp
(use-package ancilla
  ;; :ensure (:host github :repo "shouya/ancilla.el")
  :ensure nil :load-path "~/projects/ancilla/ancilla.el"
  :custom
  (ancilla-adaptor-chat-model "gpt-4o-mini")
  (ancilla-adaptor-chat-openai-api-key (auth-source-pass-get 'secret "openai/api-key"))
  )
#+end_src

* Languages and modes
** Markup formats
*** Markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands gfm-mode
  :mode (("\.md$" . gfm-mode)
         ("\.markdown$" . gfm-mode))
  :config
  (when (executable-find "pando")
    (setq markdown-command "pandoc --standalone --mathjax --from=markdown")))

;; edit-indirect is required to edit code blocks in markdown
;; summon with <C-c '>
(use-package edit-indirect
  :after markdown-mode
  :commands edit-indirect-region)
#+end_src

*** MediaWiki

#+begin_src emacs-lisp
(use-package mediawiki
  :ensure t
  :commands mediawiki-mode
  :config
  (unbind-key "<tab>" mediawiki-mode-map)
  (unbind-key "S-<tab>" mediawiki-mode-map)
  (unbind-key "S-<iso-lefttab>" mediawiki-mode-map)
  (unbind-key "<backtab>" mediawiki-mode-map)
  (unbind-key "C-<backslash>" mediawiki-mode-map)
  (unbind-key "C-c a" mediawiki-mode-map)
  (unbind-key "C-x C-s" mediawiki-mode-map)

  (bind-key "<tab>" #'completion-at-point mediawiki-mode-map)
  (bind-key "C-c !" #'shou/insert-wiki-date-link mediawiki-mode-map)
  (bind-key "C-c ." #'shou/insert-wiki-date-link mediawiki-mode-map)

  (bind-key "M-<return>" 'mediawiki-terminate-paragraph mediawiki-mode-map)

  (defun shou/default-date-from-firefox ()
    (let* ((line (shell-command-to-string "wmctrl -l -x | grep -i firefox | grep -i wiki"))
           ;; matching text like Sep 20, 2022
           (regexp "[A-Z][a-z]\\{2\\} [0-9]\\{1,2\\}, [0-9]\\{4\\}")
           (match (s-match regexp line)))
      (pcase match
        (`(,text) text)
        (_ nil))))

  (defun shou/insert-wiki-date-link (arg)
    (interactive "P")
    (let* ((format "<[%b %-d, %Y]>")
           (org-time-stamp-formats (cons format format))
           (org-read-date-prefer-future nil)
           (default-date (shou/default-date-from-firefox))
           (time (org-read-date arg 'totime nil nil nil default-date)))
      (org-insert-time-stamp time t 'inactive)))
  )
#+end_src

** Data formats

*** CSV

#+begin_src emacs-lisp
(use-package csv-mode
  :commands csv-mode
  :mode (("\\.csv\\'" . csv-mode))
  :config
  (add-hook 'csv-mode-hook 'csv-align-mode))
#+end_src

** Declarative formats

*** Dockerfile

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :mode "Dockerfile")
(use-package docker-compose-mode
  :ensure t
  :mode "docker-compose\\.ya?ml"
  :mode "fig\\.ya?ml")
#+end_src

*** Systemd unit files

#+begin_src emacs-lisp
(use-package systemd
  :ensure t
  :if (eq system-type 'gnu/linux)
  :mode (("\\.service\\'" . systemd-mode)
         ("\\.timer\\'" . systemd-mode)
         ("/etc/systemd/.*\\.conf\\'" . systemd-mode)))
#+end_src

** Emacs lisp

Shorten the mode name to =Elisp=.

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook (lambda () (setq-default mode-name "Elisp")))
#+end_src

Evaluate an expression with pretty print:

#+begin_src emacs-lisp
(bind-key "M-:" #'pp-eval-expression)
#+end_src

** Bash

#+begin_src emacs-lisp
(use-package sh-script
  ;; configure the built-in shell script mode
  :ensure nil
  :config
  ;; remove comint completion. corfu is preferred.
  (add-hook 'sh-base-mode-hook
            (lambda ()
              (remove-hook 'completion-at-point-functions #'comint-completion-at-point t))))
#+end_src

** Fish

#+begin_src emacs-lisp
(use-package fish-mode
  :ensure t
  :mode "\\.fish\\'"
  :custom
  ;; to match the same indentation as fish_indent
  (fish-indent-offset 4))
#+end_src

** Lean

#+begin_src emacs-lisp
(use-package lean4-mode
  :ensure (:host github :repo "leanprover/lean4-mode" :files ("*.el" "data")))
#+end_src

** Rust

*** Normal rust mode

#+begin_src emacs-lisp
(use-package rust-mode
  :ensure t
  :mode ("\\.rs\\'" . rust-mode)
  :init
  (when (fboundp 'rust-ts-mode)
    (setq rust-mode-treesitter-derive t))

  :bind
  (:map rust-mode-map
        ("C-c C-c C-e" . lsp-rust-analyzer-open-cargo-toml))

  :custom
  ;; do not show a buffer for format errors
  (rust-format-show-buffer nil)

  ;; set default indent size to 2. Actual indent size will be auto-detected
  (rust-indent-offset 2)

  :config
  ;; fix incorrect filename regexp in compilation mode
  ;; See https://github.com/rust-lang/rust-mode/issues/452
  (setq error_stack-regexps
        '("\\(?:at\\|',\\) \\(\\([^:\s]+\\):\\([0-9]+\\)\\)"
          2 3 nil nil 1))

  (when (assoc 'cargo compilation-error-regexp-alist-alist)
    (setf
     (cdr (assoc 'cargo compilation-error-regexp-alist-alist))
     error_stack-regexps))
  )
#+end_src

*** Rust TS mode

Tree sitter mode specific config.

#+begin_src emacs-lisp
(use-package rust-ts-mode
  :when (fboundp 'rust-ts-mode)
  :custom
  (rust-ts-mode-indent-offset 2))
#+end_src

*** Rust LSP config

#+begin_src emacs-lisp
(use-package rust-mode
  :after lsp-rust
  :custom
  ;; enable proc macro expansion in rust-analyzer
  (lsp-rust-analyzer-proc-macro-enable t)

  ;; default: "check".
  (lsp-rust-analyzer-cargo-watch-command "clippy")

  ;; enable clippy by default
  (lsp-rust-clippy-preference "on")

  ;; show variable types as inlay hints
  (lsp-rust-analyzer-server-display-inlay-hints t)
  )
#+end_src

*** Cargo

#+begin_src emacs-lisp
(use-package cargo
  :ensure t
  :bind
  (:map cargo-mode-map
        ("C-c C-c r" . cargo-process-run-release)
        ("C-c C-c C-r" . cargo-process-run)
        ("C-c C-c C-c" . cargo-process-check)
        ("C-c C-c C-k" . cargo-process-clippy)
        ("C-c C-c C-a" . cargo-process-add)
        ("C-c C-c C-f" . cargo-process-fmt)
        ("C-c C-c C-l" . cargo-process-current-test)
        )

  :hook
  (rust-mode . cargo-minor-mode)
  (rust-ts-mode . cargo-minor-mode)
  (conf-toml-mode . cargo-minor-mode)
  (toml-ts-mode . cargo-minor-mode)
  (cargo-process-mode . cargo-minor-mode)

  :custom
  ;; show backtrace in cargo-run
  (cargo-process--enable-rust-backtrace t)
  (cargo-process--command-watch "watch --why -q -x run")

  :config
  (defun cargo-process-run-release ()
    (interactive)
    (let ((cargo-process--command-run "run --release"))
      (cargo-process-run)))

  ;; I want to see any println output when running individual test
  (defun shou/cargo-process-current-test-patch (orig-fun &rest args)
    "Patch cargo-process-current-test to allow --nocapture flag"
    (let ((cargo-process--command-test--additional-args
           (concat " -- --nocapture " cargo-process--command-test--additional-args)))
      (apply orig-fun args)))
  (advice-add 'cargo-process-current-test :around #'shou/cargo-process-current-test-patch))

;; avoid conflict with cargo mode
(with-eval-after-load 'conf-mode
  (unbind-key "C-c C-c" conf-mode-map))
#+end_src

** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
  :bind (:map haskell-mode-map
              ("C-c C-c" . haskell-compile)
              ("C-c `" . haskell-interactive-bring)
              ("C-c C-l" . haskell-process-load-or-reload)
              ("C-c C-t" . haskell-process-do-type)
              ("C-c C-i" . haskell-process-do-info)
              ("M-." . haskell-mode-jump-to-def))
  :hook (haskell-mode . shou/disable-apheleia-mode)
  :mode (("\\.hs\\'" . haskell-mode))
  :custom
  ;; build with "stack build"
  (haskell-compile-cabal-build-command "stack build")
  ;; do not show error in a popup window
  (haskell-interactive-popup-errors nil)
  ;; show logs
  (haskell-process-log t)
  ;; auto load imports
  (haskell-process-auto-import-modules t)
)
#+end_src

** Nix

#+begin_src emacs-lisp
(use-package nix-mode
  :ensure t
  :mode "\\.nix\\'"
  :hook (nix-mode . lsp-deferred)
  )
#+end_src

LSP configuration

#+begin_src emacs-lisp
(use-package lsp-nix
  :config
  (setq lsp-nix-nil-server-path (f-canonical "~/.nix-profile/bin/nil")))
#+end_src

** Web mode

#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html?\\'" "\\.ts?\\'" "\\.svelte\\'")
  :custom
  ;; extra indentation mode
  (web-mode-script-padding 2)
  (web-mode-part-padding 2)
  (web-mode-style-padding 2)
  ;; indentation
  (web-mode-markup-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-css-indent-offset 2)
  )
#+end_src

** CSS

#+begin_src emacs-lisp
(use-package css-mode
  :ensure nil
  :custom
  (css-indent-offset 2)
  :config
  (add-hook 'css-mode-hook #'lsp-deferred))
#+end_src

** JavaScript

#+begin_src emacs-lisp
(use-package js
  :ensure nil
  :custom
  (js-indent-level 2)
  :config
  (with-eval-after-load 'lsp-javascript
    (setq lsp-typescript-surveys-enabled nil))
  (add-hook 'js-mode-hook #'lsp-deferred))
#+end_src

** GraphViz

Preview with =graphviz-dot-preview= (=C-c C-p=).

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :ensure t
  :custom
  (graphviz-dot-indent-width 2)
  (graphviz-dot-preview-extension "svg")
  )
#+end_src

Also enable =dot= language in org-babel.

#+begin_src emacs-lisp
(use-package org
  :ensure nil
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((dot . t))))
#+end_src

* Troubleshooting

** Startup benchmarking

#+begin_src emacs-lisp :tangle no
(use-package esup :ensure t)
#+end_src

** Scrolling benchmarking

#+begin_src emacs-lisp :tangle no
(defun scroll-up-benchmark ()
  (interactive)
  (end-of-buffer)
  (redisplay)
  (let ((oldgc gcs-done)
        (oldtime (float-time)))
    (condition-case nil (while t (previous-line) (redisplay))
      (error (message "GCs: %d Elapsed time: %f seconds"
                      (- gcs-done oldgc) (- (float-time) oldtime))))))

(defun scroll-up-profile ()
  (interactive)
  (end-of-buffer)
  (redisplay)
  (when (fboundp 'profiler-stop)
    (profiler-stop))
  (profiler-start 'cpu)
  (let ((oldgc gcs-done)
        (oldtime (float-time)))
    (condition-case nil (while t (previous-line) (redisplay))
      (error (message "GCs: %d Elapsed time: %f seconds"
                        (- gcs-done oldgc) (- (float-time) oldtime))))
    (profiler-report)
    (profiler-stop)))
#+end_src
